{"version":3,"file":"record.js","sourceRoot":"/","sources":["client/codegen/core/schemas/builders/record/record.ts"],"names":[],"mappings":"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","sourcesContent":["import { MaybeValid, Schema, SchemaType, ValidationError } from \"../../Schema\";\nimport { entries } from \"../../utils/entries\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\nimport { isPlainObject } from \"../../utils/isPlainObject\";\nimport { MaybePromise } from \"../../utils/MaybePromise\";\nimport { maybeSkipValidation } from \"../../utils/maybeSkipValidation\";\nimport { getSchemaUtils } from \"../schema-utils\";\nimport { BaseRecordSchema, RecordSchema } from \"./types\";\n\nexport function record<RawKey extends string | number, RawValue, ParsedValue, ParsedKey extends string | number>(\n    keySchema: Schema<RawKey, ParsedKey>,\n    valueSchema: Schema<RawValue, ParsedValue>\n): RecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> {\n    const baseSchema: BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> = {\n        parse: async (raw, opts) => {\n            return validateAndTransformRecord({\n                value: raw,\n                isKeyNumeric: (await keySchema.getType()) === SchemaType.NUMBER,\n                transformKey: (key) =>\n                    keySchema.parse(key, {\n                        ...opts,\n                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key} (key)`],\n                    }),\n                transformValue: (value, key) =>\n                    valueSchema.parse(value, {\n                        ...opts,\n                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key}`],\n                    }),\n                breadcrumbsPrefix: opts?.breadcrumbsPrefix,\n            });\n        },\n        json: async (parsed, opts) => {\n            return validateAndTransformRecord({\n                value: parsed,\n                isKeyNumeric: (await keySchema.getType()) === SchemaType.NUMBER,\n                transformKey: (key) =>\n                    keySchema.json(key, {\n                        ...opts,\n                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key} (key)`],\n                    }),\n                transformValue: (value, key) =>\n                    valueSchema.json(value, {\n                        ...opts,\n                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key}`],\n                    }),\n                breadcrumbsPrefix: opts?.breadcrumbsPrefix,\n            });\n        },\n        getType: () => SchemaType.RECORD,\n    };\n\n    return {\n        ...maybeSkipValidation(baseSchema),\n        ...getSchemaUtils(baseSchema),\n    };\n}\n\nasync function validateAndTransformRecord<TransformedKey extends string | number, TransformedValue>({\n    value,\n    isKeyNumeric,\n    transformKey,\n    transformValue,\n    breadcrumbsPrefix = [],\n}: {\n    value: unknown;\n    isKeyNumeric: boolean;\n    transformKey: (key: string | number) => MaybePromise<MaybeValid<TransformedKey>>;\n    transformValue: (value: unknown, key: string | number) => MaybePromise<MaybeValid<TransformedValue>>;\n    breadcrumbsPrefix: string[] | undefined;\n}): Promise<MaybeValid<Record<TransformedKey, TransformedValue>>> {\n    if (!isPlainObject(value)) {\n        return {\n            ok: false,\n            errors: [\n                {\n                    path: breadcrumbsPrefix,\n                    message: getErrorMessageForIncorrectType(value, \"object\"),\n                },\n            ],\n        };\n    }\n\n    return entries(value).reduce<Promise<MaybeValid<Record<TransformedKey, TransformedValue>>>>(\n        async (accPromise, [stringKey, value]) => {\n            // skip nullish keys\n            if (value == null) {\n                return accPromise;\n            }\n\n            const acc = await accPromise;\n\n            let key: string | number = stringKey;\n            if (isKeyNumeric) {\n                const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;\n                if (!isNaN(numberKey)) {\n                    key = numberKey;\n                }\n            }\n            const transformedKey = await transformKey(key);\n\n            const transformedValue = await transformValue(value, key);\n\n            if (acc.ok && transformedKey.ok && transformedValue.ok) {\n                return {\n                    ok: true,\n                    value: {\n                        ...acc.value,\n                        [transformedKey.value]: transformedValue.value,\n                    },\n                };\n            }\n\n            const errors: ValidationError[] = [];\n            if (!acc.ok) {\n                errors.push(...acc.errors);\n            }\n            if (!transformedKey.ok) {\n                errors.push(...transformedKey.errors);\n            }\n            if (!transformedValue.ok) {\n                errors.push(...transformedValue.errors);\n            }\n\n            return {\n                ok: false,\n                errors,\n            };\n        },\n        Promise.resolve({ ok: true, value: {} as Record<TransformedKey, TransformedValue> })\n    );\n}\n"]}