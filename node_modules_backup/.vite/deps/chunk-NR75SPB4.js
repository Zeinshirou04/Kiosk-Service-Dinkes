import {
  __export,
  __publicField
} from "./chunk-UN725CXD.js";

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/index.js
var schemas_exports = {};
__export(schemas_exports, {
  JsonError: () => JsonError,
  ParseError: () => ParseError,
  any: () => any,
  boolean: () => boolean,
  booleanLiteral: () => booleanLiteral,
  date: () => date,
  discriminant: () => discriminant,
  enum_: () => enum_,
  getObjectLikeUtils: () => getObjectLikeUtils,
  getObjectUtils: () => getObjectUtils,
  getSchemaUtils: () => getSchemaUtils,
  isProperty: () => isProperty,
  lazy: () => lazy,
  lazyObject: () => lazyObject,
  list: () => list,
  number: () => number,
  object: () => object,
  objectWithoutOptionalProperties: () => objectWithoutOptionalProperties,
  optional: () => optional,
  property: () => property,
  record: () => record,
  set: () => set,
  string: () => string,
  stringLiteral: () => stringLiteral,
  transform: () => transform,
  undiscriminatedUnion: () => undiscriminatedUnion,
  union: () => union,
  unknown: () => unknown,
  withParsedProperties: () => withParsedProperties
});

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/Schema.js
var SchemaType = {
  DATE: "date",
  ENUM: "enum",
  LIST: "list",
  STRING_LITERAL: "stringLiteral",
  BOOLEAN_LITERAL: "booleanLiteral",
  OBJECT: "object",
  ANY: "any",
  BOOLEAN: "boolean",
  NUMBER: "number",
  STRING: "string",
  UNKNOWN: "unknown",
  RECORD: "record",
  SET: "set",
  UNION: "union",
  UNDISCRIMINATED_UNION: "undiscriminatedUnion",
  OPTIONAL: "optional"
};

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/utils/getErrorMessageForIncorrectType.js
function getErrorMessageForIncorrectType(value, expectedType) {
  return `Expected ${expectedType}. Received ${getTypeAsString(value)}.`;
}
function getTypeAsString(value) {
  if (Array.isArray(value)) {
    return "list";
  }
  if (value === null) {
    return "null";
  }
  switch (typeof value) {
    case "string":
      return `"${value}"`;
    case "number":
    case "boolean":
    case "undefined":
      return `${value}`;
  }
  return typeof value;
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/utils/maybeSkipValidation.js
function maybeSkipValidation(schema) {
  return {
    ...schema,
    json: transformAndMaybeSkipValidation(schema.json),
    parse: transformAndMaybeSkipValidation(schema.parse)
  };
}
function transformAndMaybeSkipValidation(transform2) {
  return async (value, opts) => {
    const transformed = await transform2(value, opts);
    const { skipValidation = false } = opts ?? {};
    if (!transformed.ok && skipValidation) {
      console.warn([
        "Failed to validate.",
        ...transformed.errors.map((error) => "  - " + (error.path.length > 0 ? `${error.path.join(".")}: ${error.message}` : error.message))
      ].join("\n"));
      return {
        ok: true,
        value
      };
    } else {
      return transformed;
    }
  };
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/schema-utils/stringifyValidationErrors.js
function stringifyValidationError(error) {
  if (error.path.length === 0) {
    return error.message;
  }
  return `${error.path.join(" -> ")}: ${error.message}`;
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/schema-utils/JsonError.js
var JsonError = class _JsonError extends Error {
  constructor(errors) {
    super(errors.map(stringifyValidationError).join("; "));
    __publicField(this, "errors");
    this.errors = errors;
    Object.setPrototypeOf(this, _JsonError.prototype);
  }
};

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/schema-utils/ParseError.js
var ParseError = class _ParseError extends Error {
  constructor(errors) {
    super(errors.map(stringifyValidationError).join("; "));
    __publicField(this, "errors");
    this.errors = errors;
    Object.setPrototypeOf(this, _ParseError.prototype);
  }
};

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/schema-utils/getSchemaUtils.js
function getSchemaUtils(schema) {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
    parseOrThrow: async (raw, opts) => {
      const parsed = await schema.parse(raw, opts);
      if (parsed.ok) {
        return parsed.value;
      }
      throw new ParseError(parsed.errors);
    },
    jsonOrThrow: async (parsed, opts) => {
      const raw = await schema.json(parsed, opts);
      if (raw.ok) {
        return raw.value;
      }
      throw new JsonError(raw.errors);
    }
  };
}
function optional(schema) {
  const baseSchema = {
    parse: (raw, opts) => {
      if (raw == null) {
        return {
          ok: true,
          value: void 0
        };
      }
      return schema.parse(raw, opts);
    },
    json: (parsed, opts) => {
      if (parsed == null) {
        return {
          ok: true,
          value: null
        };
      }
      return schema.json(parsed, opts);
    },
    getType: () => SchemaType.OPTIONAL
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema)
  };
}
function transform(schema, transformer) {
  const baseSchema = {
    parse: async (raw, opts) => {
      const parsed = await schema.parse(raw, opts);
      if (!parsed.ok) {
        return parsed;
      }
      return {
        ok: true,
        value: transformer.transform(parsed.value)
      };
    },
    json: async (transformed, opts) => {
      const parsed = await transformer.untransform(transformed);
      return schema.json(parsed, opts);
    },
    getType: () => schema.getType()
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema)
  };
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/date/date.js
var ISO_8601_REGEX = /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
function date() {
  const baseSchema = {
    parse: (raw, { breadcrumbsPrefix = [] } = {}) => {
      if (typeof raw !== "string") {
        return {
          ok: false,
          errors: [
            {
              path: breadcrumbsPrefix,
              message: getErrorMessageForIncorrectType(raw, "string")
            }
          ]
        };
      }
      if (!ISO_8601_REGEX.test(raw)) {
        return {
          ok: false,
          errors: [
            {
              path: breadcrumbsPrefix,
              message: getErrorMessageForIncorrectType(raw, "ISO 8601 date string")
            }
          ]
        };
      }
      return {
        ok: true,
        value: new Date(raw)
      };
    },
    json: (date2, { breadcrumbsPrefix = [] } = {}) => {
      if (date2 instanceof Date) {
        return {
          ok: true,
          value: date2.toISOString()
        };
      } else {
        return {
          ok: false,
          errors: [
            {
              path: breadcrumbsPrefix,
              message: getErrorMessageForIncorrectType(date2, "Date object")
            }
          ]
        };
      }
    },
    getType: () => SchemaType.DATE
  };
  return {
    ...maybeSkipValidation(baseSchema),
    ...getSchemaUtils(baseSchema)
  };
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/utils/createIdentitySchemaCreator.js
function createIdentitySchemaCreator(schemaType, validate) {
  return () => {
    const baseSchema = {
      parse: validate,
      json: validate,
      getType: () => schemaType
    };
    return {
      ...maybeSkipValidation(baseSchema),
      ...getSchemaUtils(baseSchema)
    };
  };
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/enum/enum.js
function enum_(values) {
  const validValues = new Set(values);
  const schemaCreator = createIdentitySchemaCreator(SchemaType.ENUM, (value, { allowUnrecognizedEnumValues, breadcrumbsPrefix = [] } = {}) => {
    if (typeof value !== "string") {
      return {
        ok: false,
        errors: [
          {
            path: breadcrumbsPrefix,
            message: getErrorMessageForIncorrectType(value, "string")
          }
        ]
      };
    }
    if (!validValues.has(value) && !allowUnrecognizedEnumValues) {
      return {
        ok: false,
        errors: [
          {
            path: breadcrumbsPrefix,
            message: getErrorMessageForIncorrectType(value, "enum")
          }
        ]
      };
    }
    return {
      ok: true,
      value
    };
  });
  return schemaCreator();
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/lazy/lazy.js
function lazy(getter) {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema)
  };
}
function constructLazyBaseSchema(getter) {
  return {
    parse: async (raw, opts) => (await getMemoizedSchema(getter)).parse(raw, opts),
    json: async (parsed, opts) => (await getMemoizedSchema(getter)).json(parsed, opts),
    getType: async () => (await getMemoizedSchema(getter)).getType()
  };
}
async function getMemoizedSchema(getter) {
  const castedGetter = getter;
  if (castedGetter.__zurg_memoized == null) {
    castedGetter.__zurg_memoized = await getter();
  }
  return castedGetter.__zurg_memoized;
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/utils/entries.js
function entries(object2) {
  return Object.entries(object2);
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/utils/filterObject.js
function filterObject(obj, keysToInclude) {
  const keysToIncludeSet = new Set(keysToInclude);
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (keysToIncludeSet.has(key)) {
      acc[key] = value;
    }
    return acc;
  }, {});
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/utils/isPlainObject.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/utils/keys.js
function keys(object2) {
  return Object.keys(object2);
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/utils/partition.js
function partition(items, predicate) {
  const trueItems = [], falseItems = [];
  for (const item of items) {
    if (predicate(item)) {
      trueItems.push(item);
    } else {
      falseItems.push(item);
    }
  }
  return [trueItems, falseItems];
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/object-like/getObjectLikeUtils.js
function getObjectLikeUtils(schema) {
  return {
    withParsedProperties: (properties) => withParsedProperties(schema, properties)
  };
}
function withParsedProperties(objectLike, properties) {
  const objectSchema = {
    parse: async (raw, opts) => {
      const parsedObject = await objectLike.parse(raw, opts);
      if (!parsedObject.ok) {
        return parsedObject;
      }
      const additionalProperties = Object.entries(properties).reduce((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === "function" ? value(parsedObject.value) : value
        };
      }, {});
      return {
        ok: true,
        value: {
          ...parsedObject.value,
          ...additionalProperties
        }
      };
    },
    json: (parsed, opts) => {
      if (!isPlainObject(parsed)) {
        return {
          ok: false,
          errors: [
            {
              path: (opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [],
              message: getErrorMessageForIncorrectType(parsed, "object")
            }
          ]
        };
      }
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = filterObject(parsed, Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key)));
      return objectLike.json(parsedWithoutAddedProperties, opts);
    },
    getType: () => objectLike.getType()
  };
  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema)
  };
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/object/property.js
function property(rawKey, valueSchema) {
  return {
    rawKey,
    valueSchema,
    isProperty: true
  };
}
function isProperty(maybeProperty) {
  return maybeProperty.isProperty;
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/object/object.js
function object(schemas) {
  const baseSchema = {
    _getRawProperties: () => Promise.resolve(Object.entries(schemas).map(([parsedKey, propertySchema]) => isProperty(propertySchema) ? propertySchema.rawKey : parsedKey)),
    _getParsedProperties: () => Promise.resolve(keys(schemas)),
    parse: async (raw, opts) => {
      const rawKeyToProperty = {};
      const requiredKeys = [];
      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
        const valueSchema = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty;
        const property2 = {
          rawKey,
          parsedKey,
          valueSchema
        };
        rawKeyToProperty[rawKey] = property2;
        if (isSchemaRequired(valueSchema)) {
          requiredKeys.push(rawKey);
        }
      }
      return validateAndTransformObject({
        value: raw,
        requiredKeys,
        getProperty: (rawKey) => {
          const property2 = rawKeyToProperty[rawKey];
          if (property2 == null) {
            return void 0;
          }
          return {
            transformedKey: property2.parsedKey,
            transform: (propertyValue) => property2.valueSchema.parse(propertyValue, {
              ...opts,
              breadcrumbsPrefix: [...(opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [], rawKey]
            })
          };
        },
        unrecognizedObjectKeys: opts == null ? void 0 : opts.unrecognizedObjectKeys,
        skipValidation: opts == null ? void 0 : opts.skipValidation,
        breadcrumbsPrefix: opts == null ? void 0 : opts.breadcrumbsPrefix
      });
    },
    json: async (parsed, opts) => {
      const requiredKeys = [];
      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const valueSchema = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty;
        if (isSchemaRequired(valueSchema)) {
          requiredKeys.push(parsedKey);
        }
      }
      return validateAndTransformObject({
        value: parsed,
        requiredKeys,
        getProperty: (parsedKey) => {
          const property2 = schemas[parsedKey];
          if (property2 == null) {
            return void 0;
          }
          if (isProperty(property2)) {
            return {
              transformedKey: property2.rawKey,
              transform: (propertyValue) => property2.valueSchema.json(propertyValue, {
                ...opts,
                breadcrumbsPrefix: [...(opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [], parsedKey]
              })
            };
          } else {
            return {
              transformedKey: parsedKey,
              transform: (propertyValue) => property2.json(propertyValue, {
                ...opts,
                breadcrumbsPrefix: [...(opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [], parsedKey]
              })
            };
          }
        },
        unrecognizedObjectKeys: opts == null ? void 0 : opts.unrecognizedObjectKeys,
        skipValidation: opts == null ? void 0 : opts.skipValidation,
        breadcrumbsPrefix: opts == null ? void 0 : opts.breadcrumbsPrefix
      });
    },
    getType: () => SchemaType.OBJECT
  };
  return {
    ...maybeSkipValidation(baseSchema),
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema)
  };
}
async function validateAndTransformObject({ value, requiredKeys, getProperty, unrecognizedObjectKeys = "fail", skipValidation = false, breadcrumbsPrefix = [] }) {
  if (!isPlainObject(value)) {
    return {
      ok: false,
      errors: [
        {
          path: breadcrumbsPrefix,
          message: getErrorMessageForIncorrectType(value, "object")
        }
      ]
    };
  }
  const missingRequiredKeys = new Set(requiredKeys);
  const errors = [];
  const transformed = {};
  for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {
    const property2 = getProperty(preTransformedKey);
    if (property2 != null) {
      missingRequiredKeys.delete(preTransformedKey);
      const value2 = await property2.transform(preTransformedItemValue);
      if (value2.ok) {
        transformed[property2.transformedKey] = value2.value;
      } else {
        transformed[preTransformedKey] = preTransformedItemValue;
        errors.push(...value2.errors);
      }
    } else {
      switch (unrecognizedObjectKeys) {
        case "fail":
          errors.push({
            path: [...breadcrumbsPrefix, preTransformedKey],
            message: `Unexpected key "${preTransformedKey}"`
          });
          break;
        case "strip":
          break;
        case "passthrough":
          transformed[preTransformedKey] = preTransformedItemValue;
          break;
      }
    }
  }
  errors.push(...requiredKeys.filter((key) => missingRequiredKeys.has(key)).map((key) => ({
    path: breadcrumbsPrefix,
    message: `Missing required key "${key}"`
  })));
  if (errors.length === 0 || skipValidation) {
    return {
      ok: true,
      value: transformed
    };
  } else {
    return {
      ok: false,
      errors
    };
  }
}
function getObjectUtils(schema) {
  return {
    extend: (extension) => {
      const baseSchema = {
        _getParsedProperties: async () => [
          ...await schema._getParsedProperties(),
          ...await extension._getParsedProperties()
        ],
        _getRawProperties: async () => [
          ...await schema._getRawProperties(),
          ...await extension._getRawProperties()
        ],
        parse: async (raw, opts) => {
          return validateAndTransformExtendedObject({
            extensionKeys: await extension._getRawProperties(),
            value: raw,
            transformBase: (rawBase) => schema.parse(rawBase, opts),
            transformExtension: (rawExtension) => extension.parse(rawExtension, opts)
          });
        },
        json: async (parsed, opts) => {
          return validateAndTransformExtendedObject({
            extensionKeys: await extension._getParsedProperties(),
            value: parsed,
            transformBase: (parsedBase) => schema.json(parsedBase, opts),
            transformExtension: (parsedExtension) => extension.json(parsedExtension, opts)
          });
        },
        getType: () => SchemaType.OBJECT
      };
      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema)
      };
    }
  };
}
async function validateAndTransformExtendedObject({ extensionKeys, value, transformBase, transformExtension }) {
  const extensionPropertiesSet = new Set(extensionKeys);
  const [extensionProperties, baseProperties] = partition(keys(value), (key) => extensionPropertiesSet.has(key));
  const transformedBase = await transformBase(filterObject(value, baseProperties));
  const transformedExtension = await transformExtension(filterObject(value, extensionProperties));
  if (transformedBase.ok && transformedExtension.ok) {
    return {
      ok: true,
      value: {
        ...transformedBase.value,
        ...transformedExtension.value
      }
    };
  } else {
    return {
      ok: false,
      errors: [
        ...transformedBase.ok ? [] : transformedBase.errors,
        ...transformedExtension.ok ? [] : transformedExtension.errors
      ]
    };
  }
}
function isSchemaRequired(schema) {
  return !isSchemaOptional(schema);
}
function isSchemaOptional(schema) {
  switch (schema.getType()) {
    case SchemaType.ANY:
    case SchemaType.UNKNOWN:
    case SchemaType.OPTIONAL:
      return true;
    default:
      return false;
  }
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/object/objectWithoutOptionalProperties.js
function objectWithoutOptionalProperties(schemas) {
  return object(schemas);
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/lazy/lazyObject.js
function lazyObject(getter) {
  const baseSchema = {
    ...constructLazyBaseSchema(getter),
    _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
    _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties()
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema)
  };
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/list/list.js
function list(schema) {
  const baseSchema = {
    parse: async (raw, opts) => validateAndTransformArray(raw, (item, index) => schema.parse(item, {
      ...opts,
      breadcrumbsPrefix: [...(opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [], `[${index}]`]
    })),
    json: (parsed, opts) => validateAndTransformArray(parsed, (item, index) => schema.json(item, {
      ...opts,
      breadcrumbsPrefix: [...(opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [], `[${index}]`]
    })),
    getType: () => SchemaType.LIST
  };
  return {
    ...maybeSkipValidation(baseSchema),
    ...getSchemaUtils(baseSchema)
  };
}
async function validateAndTransformArray(value, transformItem) {
  if (!Array.isArray(value)) {
    return {
      ok: false,
      errors: [
        {
          message: getErrorMessageForIncorrectType(value, "list"),
          path: []
        }
      ]
    };
  }
  const maybeValidItems = await Promise.all(value.map((item, index) => transformItem(item, index)));
  return maybeValidItems.reduce((acc, item) => {
    if (acc.ok && item.ok) {
      return {
        ok: true,
        value: [...acc.value, item.value]
      };
    }
    const errors = [];
    if (!acc.ok) {
      errors.push(...acc.errors);
    }
    if (!item.ok) {
      errors.push(...item.errors);
    }
    return {
      ok: false,
      errors
    };
  }, { ok: true, value: [] });
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/literals/stringLiteral.js
function stringLiteral(literal) {
  const schemaCreator = createIdentitySchemaCreator(SchemaType.STRING_LITERAL, (value, { breadcrumbsPrefix = [] } = {}) => {
    if (value === literal) {
      return {
        ok: true,
        value: literal
      };
    } else {
      return {
        ok: false,
        errors: [
          {
            path: breadcrumbsPrefix,
            message: getErrorMessageForIncorrectType(value, `"${literal}"`)
          }
        ]
      };
    }
  });
  return schemaCreator();
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/literals/booleanLiteral.js
function booleanLiteral(literal) {
  const schemaCreator = createIdentitySchemaCreator(SchemaType.BOOLEAN_LITERAL, (value, { breadcrumbsPrefix = [] } = {}) => {
    if (value === literal) {
      return {
        ok: true,
        value: literal
      };
    } else {
      return {
        ok: false,
        errors: [
          {
            path: breadcrumbsPrefix,
            message: getErrorMessageForIncorrectType(value, `${literal.toString()}`)
          }
        ]
      };
    }
  });
  return schemaCreator();
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/primitives/any.js
var any = createIdentitySchemaCreator(SchemaType.ANY, (value) => ({ ok: true, value }));

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/primitives/boolean.js
var boolean = createIdentitySchemaCreator(SchemaType.BOOLEAN, (value, { breadcrumbsPrefix = [] } = {}) => {
  if (typeof value === "boolean") {
    return {
      ok: true,
      value
    };
  } else {
    return {
      ok: false,
      errors: [
        {
          path: breadcrumbsPrefix,
          message: getErrorMessageForIncorrectType(value, "boolean")
        }
      ]
    };
  }
});

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/primitives/number.js
var number = createIdentitySchemaCreator(SchemaType.NUMBER, (value, { breadcrumbsPrefix = [] } = {}) => {
  if (typeof value === "number") {
    return {
      ok: true,
      value
    };
  } else {
    return {
      ok: false,
      errors: [
        {
          path: breadcrumbsPrefix,
          message: getErrorMessageForIncorrectType(value, "number")
        }
      ]
    };
  }
});

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/primitives/string.js
var string = createIdentitySchemaCreator(SchemaType.STRING, (value, { breadcrumbsPrefix = [] } = {}) => {
  if (typeof value === "string") {
    return {
      ok: true,
      value
    };
  } else {
    return {
      ok: false,
      errors: [
        {
          path: breadcrumbsPrefix,
          message: getErrorMessageForIncorrectType(value, "string")
        }
      ]
    };
  }
});

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/primitives/unknown.js
var unknown = createIdentitySchemaCreator(SchemaType.UNKNOWN, (value) => ({ ok: true, value }));

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/record/record.js
function record(keySchema, valueSchema) {
  const baseSchema = {
    parse: async (raw, opts) => {
      return validateAndTransformRecord({
        value: raw,
        isKeyNumeric: await keySchema.getType() === SchemaType.NUMBER,
        transformKey: (key) => keySchema.parse(key, {
          ...opts,
          breadcrumbsPrefix: [...(opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [], `${key} (key)`]
        }),
        transformValue: (value, key) => valueSchema.parse(value, {
          ...opts,
          breadcrumbsPrefix: [...(opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [], `${key}`]
        }),
        breadcrumbsPrefix: opts == null ? void 0 : opts.breadcrumbsPrefix
      });
    },
    json: async (parsed, opts) => {
      return validateAndTransformRecord({
        value: parsed,
        isKeyNumeric: await keySchema.getType() === SchemaType.NUMBER,
        transformKey: (key) => keySchema.json(key, {
          ...opts,
          breadcrumbsPrefix: [...(opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [], `${key} (key)`]
        }),
        transformValue: (value, key) => valueSchema.json(value, {
          ...opts,
          breadcrumbsPrefix: [...(opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [], `${key}`]
        }),
        breadcrumbsPrefix: opts == null ? void 0 : opts.breadcrumbsPrefix
      });
    },
    getType: () => SchemaType.RECORD
  };
  return {
    ...maybeSkipValidation(baseSchema),
    ...getSchemaUtils(baseSchema)
  };
}
async function validateAndTransformRecord({ value, isKeyNumeric, transformKey, transformValue, breadcrumbsPrefix = [] }) {
  if (!isPlainObject(value)) {
    return {
      ok: false,
      errors: [
        {
          path: breadcrumbsPrefix,
          message: getErrorMessageForIncorrectType(value, "object")
        }
      ]
    };
  }
  return entries(value).reduce(async (accPromise, [stringKey, value2]) => {
    if (value2 == null) {
      return accPromise;
    }
    const acc = await accPromise;
    let key = stringKey;
    if (isKeyNumeric) {
      const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
      if (!isNaN(numberKey)) {
        key = numberKey;
      }
    }
    const transformedKey = await transformKey(key);
    const transformedValue = await transformValue(value2, key);
    if (acc.ok && transformedKey.ok && transformedValue.ok) {
      return {
        ok: true,
        value: {
          ...acc.value,
          [transformedKey.value]: transformedValue.value
        }
      };
    }
    const errors = [];
    if (!acc.ok) {
      errors.push(...acc.errors);
    }
    if (!transformedKey.ok) {
      errors.push(...transformedKey.errors);
    }
    if (!transformedValue.ok) {
      errors.push(...transformedValue.errors);
    }
    return {
      ok: false,
      errors
    };
  }, Promise.resolve({ ok: true, value: {} }));
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/set/set.js
function set(schema) {
  const listSchema = list(schema);
  const baseSchema = {
    parse: async (raw, opts) => {
      const parsedList = await listSchema.parse(raw, opts);
      if (parsedList.ok) {
        return {
          ok: true,
          value: new Set(parsedList.value)
        };
      } else {
        return parsedList;
      }
    },
    json: async (parsed, opts) => {
      if (!(parsed instanceof Set)) {
        return {
          ok: false,
          errors: [
            {
              path: (opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [],
              message: getErrorMessageForIncorrectType(parsed, "Set")
            }
          ]
        };
      }
      const jsonList = await listSchema.json([...parsed], opts);
      return jsonList;
    },
    getType: () => SchemaType.SET
  };
  return {
    ...maybeSkipValidation(baseSchema),
    ...getSchemaUtils(baseSchema)
  };
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.js
function undiscriminatedUnion(schemas) {
  const baseSchema = {
    parse: async (raw, opts) => {
      return validateAndTransformUndiscriminatedUnion((schema, opts2) => schema.parse(raw, opts2), schemas, opts);
    },
    json: async (parsed, opts) => {
      return validateAndTransformUndiscriminatedUnion((schema, opts2) => schema.json(parsed, opts2), schemas, opts);
    },
    getType: () => SchemaType.UNDISCRIMINATED_UNION
  };
  return {
    ...maybeSkipValidation(baseSchema),
    ...getSchemaUtils(baseSchema)
  };
}
async function validateAndTransformUndiscriminatedUnion(transform2, schemas, opts) {
  const errors = [];
  for (const [index, schema] of schemas.entries()) {
    const transformed = await transform2(schema, { ...opts, skipValidation: false });
    if (transformed.ok) {
      return transformed;
    } else {
      for (const error of transformed.errors) {
        errors.push({
          path: error.path,
          message: `[Variant ${index}] ${error.message}`
        });
      }
    }
  }
  return {
    ok: false,
    errors
  };
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/union/discriminant.js
function discriminant(parsedDiscriminant, rawDiscriminant) {
  return {
    parsedDiscriminant,
    rawDiscriminant
  };
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/schemas/builders/union/union.js
function union(discriminant2, union2) {
  const rawDiscriminant = typeof discriminant2 === "string" ? discriminant2 : discriminant2.rawDiscriminant;
  const parsedDiscriminant = typeof discriminant2 === "string" ? discriminant2 : discriminant2.parsedDiscriminant;
  const discriminantValueSchema = enum_(keys(union2));
  const baseSchema = {
    parse: async (raw, opts) => {
      return transformAndValidateUnion({
        value: raw,
        discriminant: rawDiscriminant,
        transformedDiscriminant: parsedDiscriminant,
        transformDiscriminantValue: (discriminantValue) => discriminantValueSchema.parse(discriminantValue, {
          allowUnrecognizedEnumValues: opts == null ? void 0 : opts.allowUnrecognizedUnionMembers,
          breadcrumbsPrefix: [...(opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [], rawDiscriminant]
        }),
        getAdditionalPropertiesSchema: (discriminantValue) => union2[discriminantValue],
        allowUnrecognizedUnionMembers: opts == null ? void 0 : opts.allowUnrecognizedUnionMembers,
        transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema) => additionalPropertiesSchema.parse(additionalProperties, opts),
        breadcrumbsPrefix: opts == null ? void 0 : opts.breadcrumbsPrefix
      });
    },
    json: async (parsed, opts) => {
      return transformAndValidateUnion({
        value: parsed,
        discriminant: parsedDiscriminant,
        transformedDiscriminant: rawDiscriminant,
        transformDiscriminantValue: (discriminantValue) => discriminantValueSchema.json(discriminantValue, {
          allowUnrecognizedEnumValues: opts == null ? void 0 : opts.allowUnrecognizedUnionMembers,
          breadcrumbsPrefix: [...(opts == null ? void 0 : opts.breadcrumbsPrefix) ?? [], parsedDiscriminant]
        }),
        getAdditionalPropertiesSchema: (discriminantValue) => union2[discriminantValue],
        allowUnrecognizedUnionMembers: opts == null ? void 0 : opts.allowUnrecognizedUnionMembers,
        transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema) => additionalPropertiesSchema.json(additionalProperties, opts),
        breadcrumbsPrefix: opts == null ? void 0 : opts.breadcrumbsPrefix
      });
    },
    getType: () => SchemaType.UNION
  };
  return {
    ...maybeSkipValidation(baseSchema),
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema)
  };
}
async function transformAndValidateUnion({ value, discriminant: discriminant2, transformedDiscriminant, transformDiscriminantValue, getAdditionalPropertiesSchema, allowUnrecognizedUnionMembers = false, transformAdditionalProperties, breadcrumbsPrefix = [] }) {
  if (!isPlainObject(value)) {
    return {
      ok: false,
      errors: [
        {
          path: breadcrumbsPrefix,
          message: getErrorMessageForIncorrectType(value, "object")
        }
      ]
    };
  }
  const { [discriminant2]: discriminantValue, ...additionalProperties } = value;
  if (discriminantValue == null) {
    return {
      ok: false,
      errors: [
        {
          path: breadcrumbsPrefix,
          message: `Missing discriminant ("${discriminant2}")`
        }
      ]
    };
  }
  const transformedDiscriminantValue = await transformDiscriminantValue(discriminantValue);
  if (!transformedDiscriminantValue.ok) {
    return {
      ok: false,
      errors: transformedDiscriminantValue.errors
    };
  }
  const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);
  if (additionalPropertiesSchema == null) {
    if (allowUnrecognizedUnionMembers) {
      return {
        ok: true,
        value: {
          [transformedDiscriminant]: transformedDiscriminantValue.value,
          ...additionalProperties
        }
      };
    } else {
      return {
        ok: false,
        errors: [
          {
            path: [...breadcrumbsPrefix, discriminant2],
            message: "Unexpected discriminant value"
          }
        ]
      };
    }
  }
  const transformedAdditionalProperties = await transformAdditionalProperties(additionalProperties, additionalPropertiesSchema);
  if (!transformedAdditionalProperties.ok) {
    return transformedAdditionalProperties;
  }
  return {
    ok: true,
    value: {
      [transformedDiscriminant]: discriminantValue,
      ...transformedAdditionalProperties.value
    }
  };
}

export {
  JsonError,
  ParseError,
  getSchemaUtils,
  optional,
  transform,
  date,
  enum_,
  lazy,
  getObjectLikeUtils,
  withParsedProperties,
  property,
  isProperty,
  object,
  getObjectUtils,
  objectWithoutOptionalProperties,
  lazyObject,
  list,
  stringLiteral,
  booleanLiteral,
  any,
  boolean,
  number,
  string,
  unknown,
  record,
  set,
  undiscriminatedUnion,
  discriminant,
  union,
  schemas_exports
};
//# sourceMappingURL=chunk-NR75SPB4.js.map
