{"version":3,"file":"Schema.js","sourceRoot":"/","sources":["client/codegen/core/schemas/Schema.ts"],"names":[],"mappings":";;;AAca,QAAA,UAAU,GAAG;IACtB,IAAI,EAAE,MAAM;IACZ,IAAI,EAAE,MAAM;IACZ,IAAI,EAAE,MAAM;IACZ,cAAc,EAAE,eAAe;IAC/B,eAAe,EAAE,gBAAgB;IACjC,MAAM,EAAE,QAAQ;IAChB,GAAG,EAAE,KAAK;IACV,OAAO,EAAE,SAAS;IAClB,MAAM,EAAE,QAAQ;IAChB,MAAM,EAAE,QAAQ;IAChB,OAAO,EAAE,SAAS;IAClB,MAAM,EAAE,QAAQ;IAChB,GAAG,EAAE,KAAK;IACV,KAAK,EAAE,OAAO;IACd,qBAAqB,EAAE,sBAAsB;IAC7C,QAAQ,EAAE,UAAU;CACd,CAAC","sourcesContent":["import { SchemaUtils } from \"./builders\";\nimport { MaybePromise } from \"./utils/MaybePromise\";\n\nexport type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;\n\nexport type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;\nexport type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;\n\nexport interface BaseSchema<Raw, Parsed> {\n    parse: (raw: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Parsed>>;\n    json: (parsed: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Raw>>;\n    getType: () => SchemaType | Promise<SchemaType>;\n}\n\nexport const SchemaType = {\n    DATE: \"date\",\n    ENUM: \"enum\",\n    LIST: \"list\",\n    STRING_LITERAL: \"stringLiteral\",\n    BOOLEAN_LITERAL: \"booleanLiteral\",\n    OBJECT: \"object\",\n    ANY: \"any\",\n    BOOLEAN: \"boolean\",\n    NUMBER: \"number\",\n    STRING: \"string\",\n    UNKNOWN: \"unknown\",\n    RECORD: \"record\",\n    SET: \"set\",\n    UNION: \"union\",\n    UNDISCRIMINATED_UNION: \"undiscriminatedUnion\",\n    OPTIONAL: \"optional\",\n} as const;\nexport type SchemaType = typeof SchemaType[keyof typeof SchemaType];\n\nexport type MaybeValid<T> = Valid<T> | Invalid;\n\nexport interface Valid<T> {\n    ok: true;\n    value: T;\n}\n\nexport interface Invalid {\n    ok: false;\n    errors: ValidationError[];\n}\n\nexport interface ValidationError {\n    path: string[];\n    message: string;\n}\n\nexport interface SchemaOptions {\n    /**\n     * how to handle unrecognized keys in objects\n     *\n     * @default \"fail\"\n     */\n    unrecognizedObjectKeys?: \"fail\" | \"passthrough\" | \"strip\";\n\n    /**\n     * whether to fail when an unrecognized discriminant value is\n     * encountered in a union\n     *\n     * @default false\n     */\n    allowUnrecognizedUnionMembers?: boolean;\n\n    /**\n     * whether to fail when an unrecognized enum value is encountered\n     *\n     * @default false\n     */\n    allowUnrecognizedEnumValues?: boolean;\n\n    /**\n     * whether to allow data that doesn't conform to the schema.\n     * invalid data is passed through without transformation.\n     *\n     * when this is enabled, .parse() and .json() will always\n     * return `ok: true`. `.parseOrThrow()` and `.jsonOrThrow()`\n     * will never fail.\n     *\n     * @default false\n     */\n    skipValidation?: boolean;\n\n    /**\n     * each validation failure contains a \"path\" property, which is\n     * the breadcrumbs to the offending node in the JSON. you can supply\n     * a prefix that is prepended to all the errors' paths. this can be\n     * helpful for zurg's internal debug logging.\n     */\n    breadcrumbsPrefix?: string[];\n}\n"]}