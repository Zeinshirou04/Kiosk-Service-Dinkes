{"version":3,"file":"set.js","sourceRoot":"/","sources":["client/codegen/core/schemas/builders/set/set.ts"],"names":[],"mappings":"AAAA,OAAO,EAAsB,UAAU,EAAE,MAAM,cAAc,CAAC;AAC9D,OAAO,EAAE,+BAA+B,EAAE,MAAM,6CAA6C,CAAC;AAC9F,OAAO,EAAE,mBAAmB,EAAE,MAAM,iCAAiC,CAAC;AACtE,OAAO,EAAE,IAAI,EAAE,MAAM,SAAS,CAAC;AAC/B,OAAO,EAAE,cAAc,EAAE,MAAM,iBAAiB,CAAC;AAEjD,MAAM,UAAU,GAAG,CAAc,MAA2B;IACxD,MAAM,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC;IAChC,MAAM,UAAU,GAAmC;QAC/C,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE;YACvB,MAAM,UAAU,GAAG,MAAM,UAAU,CAAC,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;YACrD,IAAI,UAAU,CAAC,EAAE,EAAE,CAAC;gBAChB,OAAO;oBACH,EAAE,EAAE,IAAI;oBACR,KAAK,EAAE,IAAI,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC;iBACnC,CAAC;YACN,CAAC;iBAAM,CAAC;gBACJ,OAAO,UAAU,CAAC;YACtB,CAAC;QACL,CAAC;QACD,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE;YACzB,IAAI,CAAC,CAAC,MAAM,YAAY,GAAG,CAAC,EAAE,CAAC;gBAC3B,OAAO;oBACH,EAAE,EAAE,KAAK;oBACT,MAAM,EAAE;wBACJ;4BACI,IAAI,EAAE,IAAI,EAAE,iBAAiB,IAAI,EAAE;4BACnC,OAAO,EAAE,+BAA+B,CAAC,MAAM,EAAE,KAAK,CAAC;yBAC1D;qBACJ;iBACJ,CAAC;YACN,CAAC;YACD,MAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,IAAI,CAAC,CAAC,GAAG,MAAM,CAAC,EAAE,IAAI,CAAC,CAAC;YAC1D,OAAO,QAAQ,CAAC;QACpB,CAAC;QACD,OAAO,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,GAAG;KAChC,CAAC;IAEF,OAAO;QACH,GAAG,mBAAmB,CAAC,UAAU,CAAC;QAClC,GAAG,cAAc,CAAC,UAAU,CAAC;KAChC,CAAC;AACN,CAAC","sourcesContent":["import { BaseSchema, Schema, SchemaType } from \"../../Schema\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\nimport { maybeSkipValidation } from \"../../utils/maybeSkipValidation\";\nimport { list } from \"../list\";\nimport { getSchemaUtils } from \"../schema-utils\";\n\nexport function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {\n    const listSchema = list(schema);\n    const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {\n        parse: async (raw, opts) => {\n            const parsedList = await listSchema.parse(raw, opts);\n            if (parsedList.ok) {\n                return {\n                    ok: true,\n                    value: new Set(parsedList.value),\n                };\n            } else {\n                return parsedList;\n            }\n        },\n        json: async (parsed, opts) => {\n            if (!(parsed instanceof Set)) {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: opts?.breadcrumbsPrefix ?? [],\n                            message: getErrorMessageForIncorrectType(parsed, \"Set\"),\n                        },\n                    ],\n                };\n            }\n            const jsonList = await listSchema.json([...parsed], opts);\n            return jsonList;\n        },\n        getType: () => SchemaType.SET,\n    };\n\n    return {\n        ...maybeSkipValidation(baseSchema),\n        ...getSchemaUtils(baseSchema),\n    };\n}\n"]}