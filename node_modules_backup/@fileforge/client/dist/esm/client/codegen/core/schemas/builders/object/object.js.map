{"version":3,"file":"object.js","sourceRoot":"/","sources":["client/codegen/core/schemas/builders/object/object.ts"],"names":[],"mappings":"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","sourcesContent":["import { MaybeValid, Schema, SchemaType, ValidationError } from \"../../Schema\";\nimport { entries } from \"../../utils/entries\";\nimport { filterObject } from \"../../utils/filterObject\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\nimport { isPlainObject } from \"../../utils/isPlainObject\";\nimport { keys } from \"../../utils/keys\";\nimport { MaybePromise } from \"../../utils/MaybePromise\";\nimport { maybeSkipValidation } from \"../../utils/maybeSkipValidation\";\nimport { partition } from \"../../utils/partition\";\nimport { getObjectLikeUtils } from \"../object-like\";\nimport { getSchemaUtils } from \"../schema-utils\";\nimport { isProperty } from \"./property\";\nimport {\n    BaseObjectSchema,\n    inferObjectSchemaFromPropertySchemas,\n    inferParsedObjectFromPropertySchemas,\n    inferRawObjectFromPropertySchemas,\n    ObjectSchema,\n    ObjectUtils,\n    PropertySchemas,\n} from \"./types\";\n\ninterface ObjectPropertyWithRawKey {\n    rawKey: string;\n    parsedKey: string;\n    valueSchema: Schema<any, any>;\n}\n\nexport function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(\n    schemas: T\n): inferObjectSchemaFromPropertySchemas<T> {\n    const baseSchema: BaseObjectSchema<\n        inferRawObjectFromPropertySchemas<T>,\n        inferParsedObjectFromPropertySchemas<T>\n    > = {\n        _getRawProperties: () =>\n            Promise.resolve(\n                Object.entries(schemas).map(([parsedKey, propertySchema]) =>\n                    isProperty(propertySchema) ? propertySchema.rawKey : parsedKey\n                ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]\n            ),\n        _getParsedProperties: () =>\n            Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),\n\n        parse: async (raw, opts) => {\n            const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};\n            const requiredKeys: string[] = [];\n\n            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {\n                const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;\n                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)\n                    ? schemaOrObjectProperty.valueSchema\n                    : schemaOrObjectProperty;\n\n                const property: ObjectPropertyWithRawKey = {\n                    rawKey,\n                    parsedKey: parsedKey as string,\n                    valueSchema,\n                };\n\n                rawKeyToProperty[rawKey] = property;\n\n                if (isSchemaRequired(valueSchema)) {\n                    requiredKeys.push(rawKey);\n                }\n            }\n\n            return validateAndTransformObject({\n                value: raw,\n                requiredKeys,\n                getProperty: (rawKey) => {\n                    const property = rawKeyToProperty[rawKey];\n                    if (property == null) {\n                        return undefined;\n                    }\n                    return {\n                        transformedKey: property.parsedKey,\n                        transform: (propertyValue) =>\n                            property.valueSchema.parse(propertyValue, {\n                                ...opts,\n                                breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), rawKey],\n                            }),\n                    };\n                },\n                unrecognizedObjectKeys: opts?.unrecognizedObjectKeys,\n                skipValidation: opts?.skipValidation,\n                breadcrumbsPrefix: opts?.breadcrumbsPrefix,\n            });\n        },\n\n        json: async (parsed, opts) => {\n            const requiredKeys: string[] = [];\n\n            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {\n                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)\n                    ? schemaOrObjectProperty.valueSchema\n                    : schemaOrObjectProperty;\n\n                if (isSchemaRequired(valueSchema)) {\n                    requiredKeys.push(parsedKey as string);\n                }\n            }\n\n            return validateAndTransformObject({\n                value: parsed,\n                requiredKeys,\n                getProperty: (\n                    parsedKey\n                ):\n                    | { transformedKey: string; transform: (propertyValue: unknown) => MaybePromise<MaybeValid<any>> }\n                    | undefined => {\n                    const property = schemas[parsedKey as keyof T];\n\n                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                    if (property == null) {\n                        return undefined;\n                    }\n\n                    if (isProperty(property)) {\n                        return {\n                            transformedKey: property.rawKey,\n                            transform: (propertyValue) =>\n                                property.valueSchema.json(propertyValue, {\n                                    ...opts,\n                                    breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), parsedKey],\n                                }),\n                        };\n                    } else {\n                        return {\n                            transformedKey: parsedKey,\n                            transform: (propertyValue) =>\n                                property.json(propertyValue, {\n                                    ...opts,\n                                    breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), parsedKey],\n                                }),\n                        };\n                    }\n                },\n                unrecognizedObjectKeys: opts?.unrecognizedObjectKeys,\n                skipValidation: opts?.skipValidation,\n                breadcrumbsPrefix: opts?.breadcrumbsPrefix,\n            });\n        },\n\n        getType: () => SchemaType.OBJECT,\n    };\n\n    return {\n        ...maybeSkipValidation(baseSchema),\n        ...getSchemaUtils(baseSchema),\n        ...getObjectLikeUtils(baseSchema),\n        ...getObjectUtils(baseSchema),\n    };\n}\n\nasync function validateAndTransformObject<Transformed>({\n    value,\n    requiredKeys,\n    getProperty,\n    unrecognizedObjectKeys = \"fail\",\n    skipValidation = false,\n    breadcrumbsPrefix = [],\n}: {\n    value: unknown;\n    requiredKeys: string[];\n    getProperty: (\n        preTransformedKey: string\n    ) => { transformedKey: string; transform: (propertyValue: unknown) => MaybePromise<MaybeValid<any>> } | undefined;\n    unrecognizedObjectKeys: \"fail\" | \"passthrough\" | \"strip\" | undefined;\n    skipValidation: boolean | undefined;\n    breadcrumbsPrefix: string[] | undefined;\n}): Promise<MaybeValid<Transformed>> {\n    if (!isPlainObject(value)) {\n        return {\n            ok: false,\n            errors: [\n                {\n                    path: breadcrumbsPrefix,\n                    message: getErrorMessageForIncorrectType(value, \"object\"),\n                },\n            ],\n        };\n    }\n\n    const missingRequiredKeys = new Set(requiredKeys);\n    const errors: ValidationError[] = [];\n    const transformed: Record<string | number | symbol, any> = {};\n\n    for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {\n        const property = getProperty(preTransformedKey);\n\n        if (property != null) {\n            missingRequiredKeys.delete(preTransformedKey);\n\n            const value = await property.transform(preTransformedItemValue);\n            if (value.ok) {\n                transformed[property.transformedKey] = value.value;\n            } else {\n                transformed[preTransformedKey] = preTransformedItemValue;\n                errors.push(...value.errors);\n            }\n        } else {\n            switch (unrecognizedObjectKeys) {\n                case \"fail\":\n                    errors.push({\n                        path: [...breadcrumbsPrefix, preTransformedKey],\n                        message: `Unexpected key \"${preTransformedKey}\"`,\n                    });\n                    break;\n                case \"strip\":\n                    break;\n                case \"passthrough\":\n                    transformed[preTransformedKey] = preTransformedItemValue;\n                    break;\n            }\n        }\n    }\n\n    errors.push(\n        ...requiredKeys\n            .filter((key) => missingRequiredKeys.has(key))\n            .map((key) => ({\n                path: breadcrumbsPrefix,\n                message: `Missing required key \"${key}\"`,\n            }))\n    );\n\n    if (errors.length === 0 || skipValidation) {\n        return {\n            ok: true,\n            value: transformed as Transformed,\n        };\n    } else {\n        return {\n            ok: false,\n            errors,\n        };\n    }\n}\n\nexport function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {\n    return {\n        extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {\n            const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {\n                _getParsedProperties: async () => [\n                    ...(await schema._getParsedProperties()),\n                    ...(await extension._getParsedProperties()),\n                ],\n                _getRawProperties: async () => [\n                    ...(await schema._getRawProperties()),\n                    ...(await extension._getRawProperties()),\n                ],\n                parse: async (raw, opts) => {\n                    return validateAndTransformExtendedObject({\n                        extensionKeys: await extension._getRawProperties(),\n                        value: raw,\n                        transformBase: (rawBase) => schema.parse(rawBase, opts),\n                        transformExtension: (rawExtension) => extension.parse(rawExtension, opts),\n                    });\n                },\n                json: async (parsed, opts) => {\n                    return validateAndTransformExtendedObject({\n                        extensionKeys: await extension._getParsedProperties(),\n                        value: parsed,\n                        transformBase: (parsedBase) => schema.json(parsedBase, opts),\n                        transformExtension: (parsedExtension) => extension.json(parsedExtension, opts),\n                    });\n                },\n                getType: () => SchemaType.OBJECT,\n            };\n\n            return {\n                ...baseSchema,\n                ...getSchemaUtils(baseSchema),\n                ...getObjectLikeUtils(baseSchema),\n                ...getObjectUtils(baseSchema),\n            };\n        },\n    };\n}\n\nasync function validateAndTransformExtendedObject<PreTransformedExtension, TransformedBase, TransformedExtension>({\n    extensionKeys,\n    value,\n    transformBase,\n    transformExtension,\n}: {\n    extensionKeys: (keyof PreTransformedExtension)[];\n    value: unknown;\n    transformBase: (value: unknown) => MaybePromise<MaybeValid<TransformedBase>>;\n    transformExtension: (value: unknown) => MaybePromise<MaybeValid<TransformedExtension>>;\n}): Promise<MaybeValid<TransformedBase & TransformedExtension>> {\n    const extensionPropertiesSet = new Set(extensionKeys);\n    const [extensionProperties, baseProperties] = partition(keys(value), (key) =>\n        extensionPropertiesSet.has(key as keyof PreTransformedExtension)\n    );\n\n    const transformedBase = await transformBase(filterObject(value, baseProperties));\n    const transformedExtension = await transformExtension(filterObject(value, extensionProperties));\n\n    if (transformedBase.ok && transformedExtension.ok) {\n        return {\n            ok: true,\n            value: {\n                ...transformedBase.value,\n                ...transformedExtension.value,\n            },\n        };\n    } else {\n        return {\n            ok: false,\n            errors: [\n                ...(transformedBase.ok ? [] : transformedBase.errors),\n                ...(transformedExtension.ok ? [] : transformedExtension.errors),\n            ],\n        };\n    }\n}\n\nfunction isSchemaRequired(schema: Schema<any, any>): boolean {\n    return !isSchemaOptional(schema);\n}\n\nfunction isSchemaOptional(schema: Schema<any, any>): boolean {\n    switch (schema.getType()) {\n        case SchemaType.ANY:\n        case SchemaType.UNKNOWN:\n        case SchemaType.OPTIONAL:\n            return true;\n        default:\n            return false;\n    }\n}\n"]}