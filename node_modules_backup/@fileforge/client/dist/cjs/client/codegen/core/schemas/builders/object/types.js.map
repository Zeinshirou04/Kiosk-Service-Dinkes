{"version":3,"file":"types.js","sourceRoot":"/","sources":["client/codegen/core/schemas/builders/object/types.ts"],"names":[],"mappings":"","sourcesContent":["import { BaseSchema, inferParsed, inferRaw, Schema } from \"../../Schema\";\nimport { addQuestionMarksToNullableProperties } from \"../../utils/addQuestionMarksToNullableProperties\";\nimport { ObjectLikeUtils } from \"../object-like\";\nimport { SchemaUtils } from \"../schema-utils\";\nimport { Property } from \"./property\";\n\nexport type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &\n    ObjectLikeUtils<Raw, Parsed> &\n    ObjectUtils<Raw, Parsed> &\n    SchemaUtils<Raw, Parsed>;\n\nexport interface BaseObjectSchema<Raw, Parsed> extends BaseSchema<Raw, Parsed> {\n    _getRawProperties: () => Promise<(keyof Raw)[]>;\n    _getParsedProperties: () => Promise<(keyof Parsed)[]>;\n}\n\nexport interface ObjectUtils<Raw, Parsed> {\n    extend: <RawExtension, ParsedExtension>(\n        schemas: ObjectSchema<RawExtension, ParsedExtension>\n    ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;\n}\n\nexport type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;\n\nexport type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>\n    ? Parsed\n    : never;\n\nexport type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<\n    inferRawObjectFromPropertySchemas<T>,\n    inferParsedObjectFromPropertySchemas<T>\n>;\n\nexport type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =\n    addQuestionMarksToNullableProperties<{\n        [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;\n    }>;\n\nexport type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =\n    addQuestionMarksToNullableProperties<{\n        [K in keyof T]: inferParsedPropertySchema<T[K]>;\n    }>;\n\nexport type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<\n    ParsedKeys,\n    Property<any, any, any> | Schema<any, any>\n>;\n\nexport type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<\n    any,\n    infer Raw,\n    any\n>\n    ? Raw\n    : P extends Schema<any, any>\n    ? inferRaw<P>\n    : never;\n\nexport type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<\n    any,\n    any,\n    infer Parsed\n>\n    ? Parsed\n    : P extends Schema<any, any>\n    ? inferParsed<P>\n    : never;\n\nexport type inferRawKey<\n    ParsedKey extends string | number | symbol,\n    P extends Property<any, any, any> | Schema<any, any>\n> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;\n"]}