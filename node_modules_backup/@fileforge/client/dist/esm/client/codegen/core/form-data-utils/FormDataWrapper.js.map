{"version":3,"file":"FormDataWrapper.js","sourceRoot":"/","sources":["client/codegen/core/form-data-utils/FormDataWrapper.ts"],"names":[],"mappings":"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","sourcesContent":["import { RUNTIME } from \"../runtime\";\nimport { Blob } from \"formdata-node\";\n\ninterface CrossPlatformFormData {\n  append(key: string, value: any): void;\n}\n\nclass FormDataRequestBody {\n  private fd: any;\n  private encoder: any;\n\n  constructor(fd: any) {\n    this.fd = fd;\n  }\n\n  async setup(): Promise<void> {\n    if (this.encoder == null && RUNTIME.type === \"node\") {\n      this.encoder = new (await import(\"form-data-encoder\")).FormDataEncoder(\n        this.fd,\n      );\n    }\n  }\n\n  public async needsEncoder() {\n    if (RUNTIME.type !== \"node\") {\n      return false;\n    }\n\n    try {\n      return (await import(\"node:stream\")).Readable !== undefined;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * @returns the multipart form data request\n   */\n  public async getBody(): Promise<any> {\n    if (!(await this.needsEncoder())) {\n      return this.fd;\n    } else {\n      if (this.encoder == null) {\n        await this.setup();\n      }\n\n      return (await import(\"node:stream\")).Readable.from(this.encoder);\n    }\n  }\n\n  /**\n   * @returns headers that need to be added to the multipart form data request\n   */\n  public async getHeaders(): Promise<Record<string, string>> {\n    if (!(await this.needsEncoder())) {\n      return {};\n    } else {\n      if (this.encoder == null) {\n        await this.setup();\n      }\n\n      return {\n        ...this.encoder.headers,\n        \"Content-Length\": this.encoder.length,\n      };\n    }\n  }\n}\n\n/**\n * FormDataWrapper is a utility to make form data\n * requests across both Browser and Node.js runtimes.\n */\nexport class FormDataWrapper {\n  private fd: CrossPlatformFormData | undefined;\n\n  public async append(name: string, value: any): Promise<void> {\n    if (this.fd == null) {\n      this.fd = new (await import(\"formdata-node\")).FormData();\n    }\n\n    if (name === \"options\" && typeof value === \"string\") {\n      this.fd.append(\n        \"options\",\n        new Blob([value], { type: \"application/json\" }),\n      );\n\n      return;\n    }\n\n    try {\n      const Readable = (await import(\"stream\")).Readable;\n      if (RUNTIME.type === \"node\" && value instanceof Readable) {\n        const { stream, mime } = await (\n          await import(\"stream-mime-type\")\n        ).getMimeType(value);\n\n        // If there is no filename, generate a random one. This is especially useful for multiple file operations that don't rely on filenames.\n        let fileName = (\n          (Math.random() + 1).toString(36) + \"00000000000000000\"\n        ).slice(2, 7);\n\n        this.fd.append(name, {\n          type: mime,\n          name: fileName,\n          [Symbol.toStringTag]: \"File\",\n          stream() {\n            return stream;\n          },\n        });\n\n        return;\n      }\n    } catch (e) {}\n\n    this.fd.append(name, value);\n  }\n\n  public getRequest(): FormDataRequestBody {\n    return new FormDataRequestBody(this.fd);\n  }\n}\n"]}