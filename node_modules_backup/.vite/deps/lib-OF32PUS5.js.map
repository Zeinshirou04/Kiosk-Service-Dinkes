{
  "version": 3,
  "sources": ["../../form-data-encoder/lib/index.js"],
  "sourcesContent": ["var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\n// src/util/isFunction.ts\nvar isFunction = (value) => typeof value === \"function\";\n\n// src/util/isAsyncIterable.ts\nvar isAsyncIterable = (value) => isFunction(value[Symbol.asyncIterator]);\n\n// src/util/chunk.ts\nvar MAX_CHUNK_SIZE = 65536;\nfunction* chunk(value) {\n  if (value.byteLength <= MAX_CHUNK_SIZE) {\n    yield value;\n    return;\n  }\n  let offset = 0;\n  while (offset < value.byteLength) {\n    const size = Math.min(value.byteLength - offset, MAX_CHUNK_SIZE);\n    const buffer = value.buffer.slice(offset, offset + size);\n    offset += buffer.byteLength;\n    yield new Uint8Array(buffer);\n  }\n}\n\n// src/util/getStreamIterator.ts\nasync function* readStream(readable) {\n  const reader = readable.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    yield value;\n  }\n}\nasync function* chunkStream(stream) {\n  for await (const value of stream) {\n    yield* chunk(value);\n  }\n}\nvar getStreamIterator = (source) => {\n  if (isAsyncIterable(source)) {\n    return chunkStream(source);\n  }\n  if (isFunction(source.getReader)) {\n    return chunkStream(readStream(source));\n  }\n  throw new TypeError(\n    \"Unsupported data source: Expected either ReadableStream or async iterable.\"\n  );\n};\n\n// src/util/createBoundary.ts\nvar alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\nfunction createBoundary() {\n  let size = 16;\n  let res = \"\";\n  while (size--) {\n    res += alphabet[Math.random() * alphabet.length << 0];\n  }\n  return res;\n}\n\n// src/util/normalizeValue.ts\nvar normalizeValue = (value) => String(value).replace(/\\r|\\n/g, (match, i, str) => {\n  if (match === \"\\r\" && str[i + 1] !== \"\\n\" || match === \"\\n\" && str[i - 1] !== \"\\r\") {\n    return \"\\r\\n\";\n  }\n  return match;\n});\n\n// src/util/isPlainObject.ts\nvar getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\nfunction isPlainObject(value) {\n  if (getType(value) !== \"object\") {\n    return false;\n  }\n  const pp = Object.getPrototypeOf(value);\n  if (pp === null || pp === void 0) {\n    return true;\n  }\n  const Ctor = pp.constructor && pp.constructor.toString();\n  return Ctor === Object.toString();\n}\n\n// src/util/proxyHeaders.ts\nfunction getProperty(target, prop) {\n  if (typeof prop === \"string\") {\n    for (const [name, value] of Object.entries(target)) {\n      if (prop.toLowerCase() === name.toLowerCase()) {\n        return value;\n      }\n    }\n  }\n  return void 0;\n}\nvar proxyHeaders = (object) => new Proxy(\n  object,\n  {\n    get: (target, prop) => getProperty(target, prop),\n    has: (target, prop) => getProperty(target, prop) !== void 0\n  }\n);\n\n// src/util/isFormData.ts\nvar isFormData = (value) => Boolean(\n  value && isFunction(value.constructor) && value[Symbol.toStringTag] === \"FormData\" && isFunction(value.append) && isFunction(value.getAll) && isFunction(value.entries) && isFunction(value[Symbol.iterator])\n);\n\n// src/util/escapeName.ts\nvar escapeName = (name) => String(name).replace(/\\r/g, \"%0D\").replace(/\\n/g, \"%0A\").replace(/\"/g, \"%22\");\n\n// src/util/isFile.ts\nvar isFile = (value) => Boolean(\n  value && typeof value === \"object\" && isFunction(value.constructor) && value[Symbol.toStringTag] === \"File\" && isFunction(value.stream) && value.name != null\n);\n\n// src/FormDataEncoder.ts\nvar defaultOptions = {\n  enableAdditionalHeaders: false\n};\nvar readonlyProp = { writable: false, configurable: false };\nvar _CRLF, _CRLF_BYTES, _CRLF_BYTES_LENGTH, _DASHES, _encoder, _footer, _form, _options, _getFieldHeader, getFieldHeader_fn, _getContentLength, getContentLength_fn;\nvar FormDataEncoder = class {\n  constructor(form, boundaryOrOptions, options) {\n    __privateAdd(this, _getFieldHeader);\n    /**\n     * Returns form-data content length\n     */\n    __privateAdd(this, _getContentLength);\n    __privateAdd(this, _CRLF, \"\\r\\n\");\n    __privateAdd(this, _CRLF_BYTES, void 0);\n    __privateAdd(this, _CRLF_BYTES_LENGTH, void 0);\n    __privateAdd(this, _DASHES, \"-\".repeat(2));\n    /**\n     * TextEncoder instance\n     */\n    __privateAdd(this, _encoder, new TextEncoder());\n    /**\n     * Returns form-data footer bytes\n     */\n    __privateAdd(this, _footer, void 0);\n    /**\n     * FormData instance\n     */\n    __privateAdd(this, _form, void 0);\n    /**\n     * Instance options\n     */\n    __privateAdd(this, _options, void 0);\n    if (!isFormData(form)) {\n      throw new TypeError(\"Expected first argument to be a FormData instance.\");\n    }\n    let boundary;\n    if (isPlainObject(boundaryOrOptions)) {\n      options = boundaryOrOptions;\n    } else {\n      boundary = boundaryOrOptions;\n    }\n    if (!boundary) {\n      boundary = createBoundary();\n    }\n    if (typeof boundary !== \"string\") {\n      throw new TypeError(\"Expected boundary argument to be a string.\");\n    }\n    if (options && !isPlainObject(options)) {\n      throw new TypeError(\"Expected options argument to be an object.\");\n    }\n    __privateSet(this, _form, Array.from(form.entries()));\n    __privateSet(this, _options, { ...defaultOptions, ...options });\n    __privateSet(this, _CRLF_BYTES, __privateGet(this, _encoder).encode(__privateGet(this, _CRLF)));\n    __privateSet(this, _CRLF_BYTES_LENGTH, __privateGet(this, _CRLF_BYTES).byteLength);\n    this.boundary = `form-data-boundary-${boundary}`;\n    this.contentType = `multipart/form-data; boundary=${this.boundary}`;\n    __privateSet(this, _footer, __privateGet(this, _encoder).encode(\n      `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _DASHES)}${__privateGet(this, _CRLF).repeat(2)}`\n    ));\n    const headers = {\n      \"Content-Type\": this.contentType\n    };\n    const contentLength = __privateMethod(this, _getContentLength, getContentLength_fn).call(this);\n    if (contentLength) {\n      this.contentLength = contentLength;\n      headers[\"Content-Length\"] = contentLength;\n    }\n    this.headers = proxyHeaders(Object.freeze(headers));\n    Object.defineProperties(this, {\n      boundary: readonlyProp,\n      contentType: readonlyProp,\n      contentLength: readonlyProp,\n      headers: readonlyProp\n    });\n  }\n  /**\n   * Creates an iterator allowing to go through form-data parts (with metadata).\n   * This method **will not** read the files and **will not** split values big into smaller chunks.\n   *\n   * Using this method, you can convert form-data content into Blob:\n   *\n   * @example\n   *\n   * ```ts\n   * import {Readable} from \"stream\"\n   *\n   * import {FormDataEncoder} from \"form-data-encoder\"\n   *\n   * import {FormData} from \"formdata-polyfill/esm-min.js\"\n   * import {fileFrom} from \"fetch-blob/form.js\"\n   * import {File} from \"fetch-blob/file.js\"\n   * import {Blob} from \"fetch-blob\"\n   *\n   * import fetch from \"node-fetch\"\n   *\n   * const form = new FormData()\n   *\n   * form.set(\"field\", \"Just a random string\")\n   * form.set(\"file\", new File([\"Using files is class amazing\"]))\n   * form.set(\"fileFromPath\", await fileFrom(\"path/to/a/file.txt\"))\n   *\n   * const encoder = new FormDataEncoder(form)\n   *\n   * const options = {\n   *   method: \"post\",\n   *   body: new Blob(encoder, {type: encoder.contentType})\n   * }\n   *\n   * const response = await fetch(\"https://httpbin.org/post\", options)\n   *\n   * console.log(await response.json())\n   * ```\n   */\n  *values() {\n    for (const [name, raw] of __privateGet(this, _form)) {\n      const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(\n        normalizeValue(raw)\n      );\n      yield __privateMethod(this, _getFieldHeader, getFieldHeader_fn).call(this, name, value);\n      yield value;\n      yield __privateGet(this, _CRLF_BYTES);\n    }\n    yield __privateGet(this, _footer);\n  }\n  /**\n   * Creates an async iterator allowing to perform the encoding by portions.\n   * This method reads through files and splits big values into smaller pieces (65536 bytes per each).\n   *\n   * @example\n   *\n   * ```ts\n   * import {Readable} from \"stream\"\n   *\n   * import {FormData, File, fileFromPath} from \"formdata-node\"\n   * import {FormDataEncoder} from \"form-data-encoder\"\n   *\n   * import fetch from \"node-fetch\"\n   *\n   * const form = new FormData()\n   *\n   * form.set(\"field\", \"Just a random string\")\n   * form.set(\"file\", new File([\"Using files is class amazing\"], \"file.txt\"))\n   * form.set(\"fileFromPath\", await fileFromPath(\"path/to/a/file.txt\"))\n   *\n   * const encoder = new FormDataEncoder(form)\n   *\n   * const options = {\n   *   method: \"post\",\n   *   headers: encoder.headers,\n   *   body: Readable.from(encoder.encode()) // or Readable.from(encoder)\n   * }\n   *\n   * const response = await fetch(\"https://httpbin.org/post\", options)\n   *\n   * console.log(await response.json())\n   * ```\n   */\n  async *encode() {\n    for (const part of this.values()) {\n      if (isFile(part)) {\n        yield* getStreamIterator(part.stream());\n      } else {\n        yield* chunk(part);\n      }\n    }\n  }\n  /**\n   * Creates an iterator allowing to read through the encoder data using for...of loops\n   */\n  [Symbol.iterator]() {\n    return this.values();\n  }\n  /**\n   * Creates an **async** iterator allowing to read through the encoder data using for-await...of loops\n   */\n  [Symbol.asyncIterator]() {\n    return this.encode();\n  }\n};\n_CRLF = new WeakMap();\n_CRLF_BYTES = new WeakMap();\n_CRLF_BYTES_LENGTH = new WeakMap();\n_DASHES = new WeakMap();\n_encoder = new WeakMap();\n_footer = new WeakMap();\n_form = new WeakMap();\n_options = new WeakMap();\n_getFieldHeader = new WeakSet();\ngetFieldHeader_fn = function(name, value) {\n  let header = \"\";\n  header += `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _CRLF)}`;\n  header += `Content-Disposition: form-data; name=\"${escapeName(name)}\"`;\n  if (isFile(value)) {\n    header += `; filename=\"${escapeName(value.name)}\"${__privateGet(this, _CRLF)}`;\n    header += `Content-Type: ${value.type || \"application/octet-stream\"}`;\n  }\n  if (__privateGet(this, _options).enableAdditionalHeaders === true) {\n    const size = isFile(value) ? value.size : value.byteLength;\n    if (size != null && !isNaN(size)) {\n      header += `${__privateGet(this, _CRLF)}Content-Length: ${size}`;\n    }\n  }\n  return __privateGet(this, _encoder).encode(`${header}${__privateGet(this, _CRLF).repeat(2)}`);\n};\n_getContentLength = new WeakSet();\ngetContentLength_fn = function() {\n  let length = 0;\n  for (const [name, raw] of __privateGet(this, _form)) {\n    const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(\n      normalizeValue(raw)\n    );\n    const size = isFile(value) ? value.size : value.byteLength;\n    if (size == null || isNaN(size)) {\n      return void 0;\n    }\n    length += __privateMethod(this, _getFieldHeader, getFieldHeader_fn).call(this, name, value).byteLength;\n    length += size;\n    length += __privateGet(this, _CRLF_BYTES_LENGTH);\n  }\n  return String(length + __privateGet(this, _footer).byteLength);\n};\nexport {\n  FormDataEncoder,\n  isFile,\n  isFormData\n};\n"],
  "mappings": ";;;AAAA,IAAI,gBAAgB,CAAC,KAAK,QAAQ,QAAQ;AACxC,MAAI,CAAC,OAAO,IAAI,GAAG;AACjB,UAAM,UAAU,YAAY,GAAG;AACnC;AACA,IAAI,eAAe,CAAC,KAAK,QAAQ,WAAW;AAC1C,gBAAc,KAAK,QAAQ,yBAAyB;AACpD,SAAO,SAAS,OAAO,KAAK,GAAG,IAAI,OAAO,IAAI,GAAG;AACnD;AACA,IAAI,eAAe,CAAC,KAAK,QAAQ,UAAU;AACzC,MAAI,OAAO,IAAI,GAAG;AAChB,UAAM,UAAU,mDAAmD;AACrE,oBAAkB,UAAU,OAAO,IAAI,GAAG,IAAI,OAAO,IAAI,KAAK,KAAK;AACrE;AACA,IAAI,eAAe,CAAC,KAAK,QAAQ,OAAO,WAAW;AACjD,gBAAc,KAAK,QAAQ,wBAAwB;AACnD,WAAS,OAAO,KAAK,KAAK,KAAK,IAAI,OAAO,IAAI,KAAK,KAAK;AACxD,SAAO;AACT;AACA,IAAI,kBAAkB,CAAC,KAAK,QAAQ,WAAW;AAC7C,gBAAc,KAAK,QAAQ,uBAAuB;AAClD,SAAO;AACT;AAGA,IAAI,aAAa,CAAC,UAAU,OAAO,UAAU;AAG7C,IAAI,kBAAkB,CAAC,UAAU,WAAW,MAAM,OAAO,aAAa,CAAC;AAGvE,IAAI,iBAAiB;AACrB,UAAU,MAAM,OAAO;AACrB,MAAI,MAAM,cAAc,gBAAgB;AACtC,UAAM;AACN;AAAA,EACF;AACA,MAAI,SAAS;AACb,SAAO,SAAS,MAAM,YAAY;AAChC,UAAM,OAAO,KAAK,IAAI,MAAM,aAAa,QAAQ,cAAc;AAC/D,UAAM,SAAS,MAAM,OAAO,MAAM,QAAQ,SAAS,IAAI;AACvD,cAAU,OAAO;AACjB,UAAM,IAAI,WAAW,MAAM;AAAA,EAC7B;AACF;AAGA,gBAAgB,WAAW,UAAU;AACnC,QAAM,SAAS,SAAS,UAAU;AAClC,SAAO,MAAM;AACX,UAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,QAAI,MAAM;AACR;AAAA,IACF;AACA,UAAM;AAAA,EACR;AACF;AACA,gBAAgB,YAAY,QAAQ;AAClC,mBAAiB,SAAS,QAAQ;AAChC,WAAO,MAAM,KAAK;AAAA,EACpB;AACF;AACA,IAAI,oBAAoB,CAAC,WAAW;AAClC,MAAI,gBAAgB,MAAM,GAAG;AAC3B,WAAO,YAAY,MAAM;AAAA,EAC3B;AACA,MAAI,WAAW,OAAO,SAAS,GAAG;AAChC,WAAO,YAAY,WAAW,MAAM,CAAC;AAAA,EACvC;AACA,QAAM,IAAI;AAAA,IACR;AAAA,EACF;AACF;AAGA,IAAI,WAAW;AACf,SAAS,iBAAiB;AACxB,MAAI,OAAO;AACX,MAAI,MAAM;AACV,SAAO,QAAQ;AACb,WAAO,SAAS,KAAK,OAAO,IAAI,SAAS,UAAU,CAAC;AAAA,EACtD;AACA,SAAO;AACT;AAGA,IAAI,iBAAiB,CAAC,UAAU,OAAO,KAAK,EAAE,QAAQ,UAAU,CAAC,OAAO,GAAG,QAAQ;AACjF,MAAI,UAAU,QAAQ,IAAI,IAAI,CAAC,MAAM,QAAQ,UAAU,QAAQ,IAAI,IAAI,CAAC,MAAM,MAAM;AAClF,WAAO;AAAA,EACT;AACA,SAAO;AACT,CAAC;AAGD,IAAI,UAAU,CAAC,UAAU,OAAO,UAAU,SAAS,KAAK,KAAK,EAAE,MAAM,GAAG,EAAE,EAAE,YAAY;AACxF,SAAS,cAAc,OAAO;AAC5B,MAAI,QAAQ,KAAK,MAAM,UAAU;AAC/B,WAAO;AAAA,EACT;AACA,QAAM,KAAK,OAAO,eAAe,KAAK;AACtC,MAAI,OAAO,QAAQ,OAAO,QAAQ;AAChC,WAAO;AAAA,EACT;AACA,QAAM,OAAO,GAAG,eAAe,GAAG,YAAY,SAAS;AACvD,SAAO,SAAS,OAAO,SAAS;AAClC;AAGA,SAAS,YAAY,QAAQ,MAAM;AACjC,MAAI,OAAO,SAAS,UAAU;AAC5B,eAAW,CAAC,MAAM,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AAClD,UAAI,KAAK,YAAY,MAAM,KAAK,YAAY,GAAG;AAC7C,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AACA,IAAI,eAAe,CAAC,WAAW,IAAI;AAAA,EACjC;AAAA,EACA;AAAA,IACE,KAAK,CAAC,QAAQ,SAAS,YAAY,QAAQ,IAAI;AAAA,IAC/C,KAAK,CAAC,QAAQ,SAAS,YAAY,QAAQ,IAAI,MAAM;AAAA,EACvD;AACF;AAGA,IAAI,aAAa,CAAC,UAAU;AAAA,EAC1B,SAAS,WAAW,MAAM,WAAW,KAAK,MAAM,OAAO,WAAW,MAAM,cAAc,WAAW,MAAM,MAAM,KAAK,WAAW,MAAM,MAAM,KAAK,WAAW,MAAM,OAAO,KAAK,WAAW,MAAM,OAAO,QAAQ,CAAC;AAC9M;AAGA,IAAI,aAAa,CAAC,SAAS,OAAO,IAAI,EAAE,QAAQ,OAAO,KAAK,EAAE,QAAQ,OAAO,KAAK,EAAE,QAAQ,MAAM,KAAK;AAGvG,IAAI,SAAS,CAAC,UAAU;AAAA,EACtB,SAAS,OAAO,UAAU,YAAY,WAAW,MAAM,WAAW,KAAK,MAAM,OAAO,WAAW,MAAM,UAAU,WAAW,MAAM,MAAM,KAAK,MAAM,QAAQ;AAC3J;AAGA,IAAI,iBAAiB;AAAA,EACnB,yBAAyB;AAC3B;AACA,IAAI,eAAe,EAAE,UAAU,OAAO,cAAc,MAAM;AAC1D,IAAI;AAAJ,IAAW;AAAX,IAAwB;AAAxB,IAA4C;AAA5C,IAAqD;AAArD,IAA+D;AAA/D,IAAwE;AAAxE,IAA+E;AAA/E,IAAyF;AAAzF,IAA0G;AAA1G,IAA6H;AAA7H,IAAgJ;AAChJ,IAAI,kBAAkB,MAAM;AAAA,EAC1B,YAAY,MAAM,mBAAmB,SAAS;AAC5C,iBAAa,MAAM,eAAe;AAIlC,iBAAa,MAAM,iBAAiB;AACpC,iBAAa,MAAM,OAAO,MAAM;AAChC,iBAAa,MAAM,aAAa,MAAM;AACtC,iBAAa,MAAM,oBAAoB,MAAM;AAC7C,iBAAa,MAAM,SAAS,IAAI,OAAO,CAAC,CAAC;AAIzC,iBAAa,MAAM,UAAU,IAAI,YAAY,CAAC;AAI9C,iBAAa,MAAM,SAAS,MAAM;AAIlC,iBAAa,MAAM,OAAO,MAAM;AAIhC,iBAAa,MAAM,UAAU,MAAM;AACnC,QAAI,CAAC,WAAW,IAAI,GAAG;AACrB,YAAM,IAAI,UAAU,oDAAoD;AAAA,IAC1E;AACA,QAAI;AACJ,QAAI,cAAc,iBAAiB,GAAG;AACpC,gBAAU;AAAA,IACZ,OAAO;AACL,iBAAW;AAAA,IACb;AACA,QAAI,CAAC,UAAU;AACb,iBAAW,eAAe;AAAA,IAC5B;AACA,QAAI,OAAO,aAAa,UAAU;AAChC,YAAM,IAAI,UAAU,4CAA4C;AAAA,IAClE;AACA,QAAI,WAAW,CAAC,cAAc,OAAO,GAAG;AACtC,YAAM,IAAI,UAAU,4CAA4C;AAAA,IAClE;AACA,iBAAa,MAAM,OAAO,MAAM,KAAK,KAAK,QAAQ,CAAC,CAAC;AACpD,iBAAa,MAAM,UAAU,EAAE,GAAG,gBAAgB,GAAG,QAAQ,CAAC;AAC9D,iBAAa,MAAM,aAAa,aAAa,MAAM,QAAQ,EAAE,OAAO,aAAa,MAAM,KAAK,CAAC,CAAC;AAC9F,iBAAa,MAAM,oBAAoB,aAAa,MAAM,WAAW,EAAE,UAAU;AACjF,SAAK,WAAW,sBAAsB,QAAQ;AAC9C,SAAK,cAAc,iCAAiC,KAAK,QAAQ;AACjE,iBAAa,MAAM,SAAS,aAAa,MAAM,QAAQ,EAAE;AAAA,MACvD,GAAG,aAAa,MAAM,OAAO,CAAC,GAAG,KAAK,QAAQ,GAAG,aAAa,MAAM,OAAO,CAAC,GAAG,aAAa,MAAM,KAAK,EAAE,OAAO,CAAC,CAAC;AAAA,IACpH,CAAC;AACD,UAAM,UAAU;AAAA,MACd,gBAAgB,KAAK;AAAA,IACvB;AACA,UAAM,gBAAgB,gBAAgB,MAAM,mBAAmB,mBAAmB,EAAE,KAAK,IAAI;AAC7F,QAAI,eAAe;AACjB,WAAK,gBAAgB;AACrB,cAAQ,gBAAgB,IAAI;AAAA,IAC9B;AACA,SAAK,UAAU,aAAa,OAAO,OAAO,OAAO,CAAC;AAClD,WAAO,iBAAiB,MAAM;AAAA,MAC5B,UAAU;AAAA,MACV,aAAa;AAAA,MACb,eAAe;AAAA,MACf,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuCA,CAAC,SAAS;AACR,eAAW,CAAC,MAAM,GAAG,KAAK,aAAa,MAAM,KAAK,GAAG;AACnD,YAAM,QAAQ,OAAO,GAAG,IAAI,MAAM,aAAa,MAAM,QAAQ,EAAE;AAAA,QAC7D,eAAe,GAAG;AAAA,MACpB;AACA,YAAM,gBAAgB,MAAM,iBAAiB,iBAAiB,EAAE,KAAK,MAAM,MAAM,KAAK;AACtF,YAAM;AACN,YAAM,aAAa,MAAM,WAAW;AAAA,IACtC;AACA,UAAM,aAAa,MAAM,OAAO;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkCA,OAAO,SAAS;AACd,eAAW,QAAQ,KAAK,OAAO,GAAG;AAChC,UAAI,OAAO,IAAI,GAAG;AAChB,eAAO,kBAAkB,KAAK,OAAO,CAAC;AAAA,MACxC,OAAO;AACL,eAAO,MAAM,IAAI;AAAA,MACnB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,CAAC,OAAO,QAAQ,IAAI;AAClB,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAIA,CAAC,OAAO,aAAa,IAAI;AACvB,WAAO,KAAK,OAAO;AAAA,EACrB;AACF;AACA,QAAQ,oBAAI,QAAQ;AACpB,cAAc,oBAAI,QAAQ;AAC1B,qBAAqB,oBAAI,QAAQ;AACjC,UAAU,oBAAI,QAAQ;AACtB,WAAW,oBAAI,QAAQ;AACvB,UAAU,oBAAI,QAAQ;AACtB,QAAQ,oBAAI,QAAQ;AACpB,WAAW,oBAAI,QAAQ;AACvB,kBAAkB,oBAAI,QAAQ;AAC9B,oBAAoB,SAAS,MAAM,OAAO;AACxC,MAAI,SAAS;AACb,YAAU,GAAG,aAAa,MAAM,OAAO,CAAC,GAAG,KAAK,QAAQ,GAAG,aAAa,MAAM,KAAK,CAAC;AACpF,YAAU,yCAAyC,WAAW,IAAI,CAAC;AACnE,MAAI,OAAO,KAAK,GAAG;AACjB,cAAU,eAAe,WAAW,MAAM,IAAI,CAAC,IAAI,aAAa,MAAM,KAAK,CAAC;AAC5E,cAAU,iBAAiB,MAAM,QAAQ,0BAA0B;AAAA,EACrE;AACA,MAAI,aAAa,MAAM,QAAQ,EAAE,4BAA4B,MAAM;AACjE,UAAM,OAAO,OAAO,KAAK,IAAI,MAAM,OAAO,MAAM;AAChD,QAAI,QAAQ,QAAQ,CAAC,MAAM,IAAI,GAAG;AAChC,gBAAU,GAAG,aAAa,MAAM,KAAK,CAAC,mBAAmB,IAAI;AAAA,IAC/D;AAAA,EACF;AACA,SAAO,aAAa,MAAM,QAAQ,EAAE,OAAO,GAAG,MAAM,GAAG,aAAa,MAAM,KAAK,EAAE,OAAO,CAAC,CAAC,EAAE;AAC9F;AACA,oBAAoB,oBAAI,QAAQ;AAChC,sBAAsB,WAAW;AAC/B,MAAI,SAAS;AACb,aAAW,CAAC,MAAM,GAAG,KAAK,aAAa,MAAM,KAAK,GAAG;AACnD,UAAM,QAAQ,OAAO,GAAG,IAAI,MAAM,aAAa,MAAM,QAAQ,EAAE;AAAA,MAC7D,eAAe,GAAG;AAAA,IACpB;AACA,UAAM,OAAO,OAAO,KAAK,IAAI,MAAM,OAAO,MAAM;AAChD,QAAI,QAAQ,QAAQ,MAAM,IAAI,GAAG;AAC/B,aAAO;AAAA,IACT;AACA,cAAU,gBAAgB,MAAM,iBAAiB,iBAAiB,EAAE,KAAK,MAAM,MAAM,KAAK,EAAE;AAC5F,cAAU;AACV,cAAU,aAAa,MAAM,kBAAkB;AAAA,EACjD;AACA,SAAO,OAAO,SAAS,aAAa,MAAM,OAAO,EAAE,UAAU;AAC/D;",
  "names": []
}
