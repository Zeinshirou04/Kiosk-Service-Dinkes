"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @vitest-environment node
 */
const vitest_1 = require("vitest");
const vitest_2 = require("vitest");
const client_1 = require("@/client");
const fs = __importStar(require("node:fs"));
const node_stream_1 = require("node:stream");
const promises_1 = require("node:stream/promises");
const NODE_VERSION = parseInt(process.versions.node.split(".")[0]);
(0, vitest_2.describe)("node", () => {
    (0, vitest_1.beforeAll)(() => {
        if (!process.env.FILEFORGE_API_KEY) {
            throw new Error("FILEFORGE_API_KEY is not set");
        }
    });
    (0, vitest_2.it)("convert docx snippet should work", async () => {
        const ff = new client_1.FileforgeClient({
            apiKey: process.env.FILEFORGE_API_KEY,
        });
        try {
            const docxFile = fs.createReadStream(__dirname + "/samples/document-simple.docx");
            const pdfStream = await ff.pdf.fromDocx(docxFile, {}, {
                timeoutInSeconds: 30,
            });
            pdfStream.pipe(fs.createWriteStream("./result_docx.pdf"));
            console.log("PDF conversion successful. Stream ready.");
            (0, vitest_2.expect)(pdfStream).toBeInstanceOf(node_stream_1.Readable);
        }
        catch (error) {
            console.error("Error during PDF conversion:", error);
            throw error;
        }
    }, 30000);
    vitest_2.it.skipIf(NODE_VERSION < 20)("generate from HTML should work", async () => {
        const ff = new client_1.FileforgeClient({
            apiKey: process.env.FILEFORGE_API_KEY,
        });
        try {
            const pdf = await ff.pdf.generate([
                new File(["<!doctype html><html><body><h1>Hello world</h1></body></html>"], "index.html", {
                    type: "text/html",
                }),
            ], {
                options: {
                    host: true,
                },
            }, {
                timeoutInSeconds: 30,
            });
            console.log(pdf.url);
            (0, vitest_2.expect)(pdf.url).toBeDefined();
        }
        catch (error) {
            console.error("Error during PDF generation:", error);
            throw error;
        }
    });
    vitest_2.it.skipIf(NODE_VERSION < 20)("merge PDFs should work", async () => {
        const ff = new client_1.FileforgeClient({
            apiKey: process.env.FILEFORGE_API_KEY,
        });
        try {
            const pdfFiles = [
                fs.createReadStream(__dirname + "/pdf1.pdf"),
                fs.createReadStream(__dirname + "/pdf2.pdf"),
            ];
            const mergedPdfStream = await ff.pdf.merge(pdfFiles, {
                options: {
                // Specify merge options if any
                },
            }, {
                timeoutInSeconds: 60,
            });
            mergedPdfStream.pipe(fs.createWriteStream("./result_merge.pdf"));
            console.log("PDF merge successful. Stream ready.");
            (0, vitest_2.expect)(mergedPdfStream).toBeInstanceOf(node_stream_1.Readable);
        }
        catch (error) {
            console.error("Error during PDF merge:", error);
            throw error;
        }
    });
    vitest_2.it.skipIf(NODE_VERSION < 20)("detect form fields in PDFs should work", async () => {
        const ff = new client_1.FileforgeClient({
            apiKey: process.env.FILEFORGE_API_KEY,
        });
        try {
            const resultObject = await ff.pdf.form.detect(new File([fs.readFileSync(__dirname + "/samples/form.pdf")], "form.pdf", {
                type: "application/pdf",
            }), { options: {} });
            console.log(resultObject);
            (0, vitest_2.expect)(resultObject).toBeInstanceOf((Array));
        }
        catch (error) {
            console.error("Error during PDF form detect:", error);
            throw error;
        }
    });
    vitest_2.it.skipIf(NODE_VERSION < 20)("mark fields in PDFs should work", async () => {
        const ff = new client_1.FileforgeClient({
            apiKey: process.env.FILEFORGE_API_KEY,
        });
        try {
            const pdfStream = await ff.pdf.form.mark(new File([fs.readFileSync(__dirname + "/samples/form.pdf")], "form.pdf", {
                type: "application/pdf",
            }), { options: {} });
            pdfStream.pipe(fs.createWriteStream("./result_mark.pdf"));
            (0, vitest_2.expect)(pdfStream).toBeInstanceOf(node_stream_1.Readable);
        }
        catch (error) {
            console.error("Error during PDF form mark:", error);
            throw error;
        }
    });
    vitest_2.it.skipIf(NODE_VERSION < 20)("fill fields in PDFs should work", async () => {
        const ff = new client_1.FileforgeClient({
            apiKey: process.env.FILEFORGE_API_KEY,
        });
        try {
            const formFillRequest = {
                options: {
                    fields: [
                        {
                            name: "Producer Name",
                            type: "PDFTextField",
                            value: "Titouan Launay",
                        },
                    ],
                },
            };
            const requestOptions = {
                timeoutInSeconds: 60,
                maxRetries: 3,
            };
            const filledPdfStream = await ff.pdf.form.fill(new File([fs.readFileSync(__dirname + "/samples/form.pdf")], "form.pdf", {
                type: "application/pdf",
            }), formFillRequest, requestOptions);
            filledPdfStream.pipe(fs.createWriteStream("./result_filled.pdf"));
            (0, vitest_2.expect)(filledPdfStream).toBeInstanceOf(node_stream_1.Readable);
            console.log("PDF form filling successful. Stream ready.");
        }
        catch (error) {
            console.error("Error during PDF form filling:", error);
        }
    });
    vitest_2.it.skipIf(NODE_VERSION < 20)("Split", async () => {
        const ff = new client_1.FileforgeClient({
            apiKey: process.env.FILEFORGE_API_KEY,
        });
        try {
            const splitRequest = {
                options: {
                    splitPage: 1,
                },
            };
            const requestOptions = {
                timeoutInSeconds: 60,
                maxRetries: 3,
            };
            const splitArchiveStream = await ff.pdf.split(new File([fs.readFileSync(__dirname + "/samples/form.pdf")], "form.pdf", {
                type: "application/pdf",
            }), splitRequest, requestOptions);
            await (0, promises_1.pipeline)(splitArchiveStream, fs.createWriteStream("./result_split.zip"));
            (0, vitest_2.expect)(splitArchiveStream).toBeInstanceOf(node_stream_1.Readable);
            console.log("Split successful. Zip Stream ready.");
        }
        catch (error) {
            console.error("Error during PDF splitting:", error);
        }
    });
    vitest_2.it.skipIf(NODE_VERSION < 20)("Extract", async () => {
        const ff = new client_1.FileforgeClient({
            apiKey: process.env.FILEFORGE_API_KEY,
        });
        try {
            const extractRequest = {
                options: {
                    start: 1,
                    end: 1,
                },
            };
            const requestOptions = {
                timeoutInSeconds: 60,
                maxRetries: 3,
            };
            const extractStream = await ff.pdf.extract(new File([fs.readFileSync(__dirname + "/samples/form.pdf")], "form.pdf", {
                type: "application/pdf",
            }), extractRequest, requestOptions);
            await (0, promises_1.pipeline)(extractStream, fs.createWriteStream("./result_extract.pdf"));
            (0, vitest_2.expect)(extractStream).toBeInstanceOf(node_stream_1.Readable);
            console.log("Extraction successful.Stream ready.");
        }
        catch (error) {
            console.error("Error during PDF extraction:", error);
        }
    });
    vitest_2.it.skipIf(NODE_VERSION < 20)("Insert PDFs should work", async () => {
        const ff = new client_1.FileforgeClient({
            apiKey: process.env.FILEFORGE_API_KEY,
        });
        try {
            const pdfFiles = [
                fs.createReadStream(__dirname + "/pdf1.pdf"),
                fs.createReadStream(__dirname + "/pdf2.pdf"),
            ];
            const insertPDFStream = await ff.pdf.insert(pdfFiles, {
                options: {
                    // Specify insert options if any
                    insertPage: 1,
                },
            }, {
                timeoutInSeconds: 60,
            });
            insertPDFStream.pipe(fs.createWriteStream("./result_insert.pdf"));
            console.log("PDF inserted successfully. Stream ready.");
            (0, vitest_2.expect)(insertPDFStream).toBeInstanceOf(node_stream_1.Readable);
        }
        catch (error) {
            console.error("Error during PDF insertion:", error);
            throw error;
        }
    });
});
//# sourceMappingURL=snippets.test.js.map