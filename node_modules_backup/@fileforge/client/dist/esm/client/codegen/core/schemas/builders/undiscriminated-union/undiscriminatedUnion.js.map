{"version":3,"file":"undiscriminatedUnion.js","sourceRoot":"/","sources":["client/codegen/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.ts"],"names":[],"mappings":"AAAA,OAAO,EAAiD,UAAU,EAAmB,MAAM,cAAc,CAAC;AAE1G,OAAO,EAAE,mBAAmB,EAAE,MAAM,iCAAiC,CAAC;AACtE,OAAO,EAAE,cAAc,EAAE,MAAM,iBAAiB,CAAC;AAGjD,MAAM,UAAU,oBAAoB,CAChC,OAAgB;IAEhB,MAAM,UAAU,GAGZ;QACA,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE;YACvB,OAAO,wCAAwC,CAC3C,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,EACzC,OAAO,EACP,IAAI,CACP,CAAC;QACN,CAAC;QACD,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE;YACzB,OAAO,wCAAwC,CAC3C,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,EAC3C,OAAO,EACP,IAAI,CACP,CAAC;QACN,CAAC;QACD,OAAO,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,qBAAqB;KAClD,CAAC;IAEF,OAAO;QACH,GAAG,mBAAmB,CAAC,UAAU,CAAC;QAClC,GAAG,cAAc,CAAC,UAAU,CAAC;KAChC,CAAC;AACN,CAAC;AAED,KAAK,UAAU,wCAAwC,CACnD,SAAmG,EACnG,OAA2B,EAC3B,IAA+B;IAE/B,MAAM,MAAM,GAAsB,EAAE,CAAC;IACrC,KAAK,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,IAAI,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;QAC9C,MAAM,WAAW,GAAG,MAAM,SAAS,CAAC,MAAM,EAAE,EAAE,GAAG,IAAI,EAAE,cAAc,EAAE,KAAK,EAAE,CAAC,CAAC;QAChF,IAAI,WAAW,CAAC,EAAE,EAAE,CAAC;YACjB,OAAO,WAAW,CAAC;QACvB,CAAC;aAAM,CAAC;YACJ,KAAK,MAAM,KAAK,IAAI,WAAW,CAAC,MAAM,EAAE,CAAC;gBACrC,MAAM,CAAC,IAAI,CAAC;oBACR,IAAI,EAAE,KAAK,CAAC,IAAI;oBAChB,OAAO,EAAE,YAAY,KAAK,KAAK,KAAK,CAAC,OAAO,EAAE;iBACjD,CAAC,CAAC;YACP,CAAC;QACL,CAAC;IACL,CAAC;IAED,OAAO;QACH,EAAE,EAAE,KAAK;QACT,MAAM;KACT,CAAC;AACN,CAAC","sourcesContent":["import { BaseSchema, MaybeValid, Schema, SchemaOptions, SchemaType, ValidationError } from \"../../Schema\";\nimport { MaybePromise } from \"../../utils/MaybePromise\";\nimport { maybeSkipValidation } from \"../../utils/maybeSkipValidation\";\nimport { getSchemaUtils } from \"../schema-utils\";\nimport { inferParsedUnidiscriminatedUnionSchema, inferRawUnidiscriminatedUnionSchema } from \"./types\";\n\nexport function undiscriminatedUnion<Schemas extends [Schema<any, any>, ...Schema<any, any>[]]>(\n    schemas: Schemas\n): Schema<inferRawUnidiscriminatedUnionSchema<Schemas>, inferParsedUnidiscriminatedUnionSchema<Schemas>> {\n    const baseSchema: BaseSchema<\n        inferRawUnidiscriminatedUnionSchema<Schemas>,\n        inferParsedUnidiscriminatedUnionSchema<Schemas>\n    > = {\n        parse: async (raw, opts) => {\n            return validateAndTransformUndiscriminatedUnion<inferParsedUnidiscriminatedUnionSchema<Schemas>>(\n                (schema, opts) => schema.parse(raw, opts),\n                schemas,\n                opts\n            );\n        },\n        json: async (parsed, opts) => {\n            return validateAndTransformUndiscriminatedUnion<inferRawUnidiscriminatedUnionSchema<Schemas>>(\n                (schema, opts) => schema.json(parsed, opts),\n                schemas,\n                opts\n            );\n        },\n        getType: () => SchemaType.UNDISCRIMINATED_UNION,\n    };\n\n    return {\n        ...maybeSkipValidation(baseSchema),\n        ...getSchemaUtils(baseSchema),\n    };\n}\n\nasync function validateAndTransformUndiscriminatedUnion<Transformed>(\n    transform: (schema: Schema<any, any>, opts: SchemaOptions) => MaybePromise<MaybeValid<Transformed>>,\n    schemas: Schema<any, any>[],\n    opts: SchemaOptions | undefined\n): Promise<MaybeValid<Transformed>> {\n    const errors: ValidationError[] = [];\n    for (const [index, schema] of schemas.entries()) {\n        const transformed = await transform(schema, { ...opts, skipValidation: false });\n        if (transformed.ok) {\n            return transformed;\n        } else {\n            for (const error of transformed.errors) {\n                errors.push({\n                    path: error.path,\n                    message: `[Variant ${index}] ${error.message}`,\n                });\n            }\n        }\n    }\n\n    return {\n        ok: false,\n        errors,\n    };\n}\n"]}