import { read } from 'fs';
import { parse as parsePath } from 'path';
import { promisify } from 'util';
import { fileTypeFromBuffer } from 'file-type';
import { lookup as mimeLookup } from 'mime-types';
import streamHead from 'stream-head';
const fsRead = promisify(read);
const fileTypeBufferLength = 4100;
const octetStream = 'application/octet-stream';
function mimeFromFilename(filename) {
    if (!filename)
        return undefined;
    const { ext } = parsePath(filename);
    return mimeLookup(ext) || undefined;
}
async function getMimeTypeOfBuffer(data, options) {
    const fileTypeData = await fileTypeFromBuffer(data);
    if (fileTypeData)
        return fileTypeData.mime;
    const { filename, strict } = options ?? {};
    return (filename ? mimeFromFilename(filename) : undefined)
        ?? (strict ? undefined : octetStream);
}
export async function getMimeType(data, options) {
    const _options = options;
    if (typeof data === 'number')
        return {
            mime: await getMimeTypeOfFd(data, _options)
        };
    if (data instanceof Uint8Array) // Includes Node.js Buffer
        return {
            mime: await getMimeTypeOfBuffer(data, _options)
        };
    else {
        const { head, stream } = await streamHead(data, { bytes: fileTypeBufferLength });
        return {
            stream,
            mime: await (await getMimeType(head, _options)).mime,
        };
    }
}
async function getMimeTypeOfFd(fd, options) {
    const buffer = Buffer.allocUnsafe(fileTypeBufferLength);
    const { bytesRead } = await fsRead(fd, buffer, 0, fileTypeBufferLength, 0);
    //console.log("SS", bytesRead)
    if (!bytesRead)
        return mimeFromFilename(options?.filename) ??
            (options?.strict ? undefined : octetStream);
    if (bytesRead < fileTypeBufferLength)
        buffer.fill(0, bytesRead, fileTypeBufferLength - bytesRead);
    return getMimeTypeOfBuffer(buffer, options);
}
