import through2 from 'through2';
function isWhatwgStream(stream) {
    return typeof stream.getReader === 'function' &&
        typeof stream.pipeThrough === 'function';
}
export default function (readable, opts) {
    if (isWhatwgStream(readable))
        return streamHeadWhatwg(readable, opts.bytes);
    else
        return streamHeadNode(readable, opts.bytes);
}
function isDataChunk(arr) {
    if (arr instanceof Int8Array
        || arr instanceof Uint8Array
        || arr instanceof Uint8ClampedArray
        || arr instanceof Int16Array
        || arr instanceof Uint16Array
        || arr instanceof Int32Array
        || arr instanceof Uint32Array
        || arr instanceof Float32Array
        || arr instanceof Float64Array
        || arr instanceof ArrayBuffer
        || arr instanceof SharedArrayBuffer
        || arr instanceof DataView)
        return true;
    return false;
}
function ensureTypedArray(chunk) {
    if (chunk instanceof DataView)
        return new Uint8Array(chunk.buffer);
    else if (chunk instanceof ArrayBuffer || chunk instanceof SharedArrayBuffer)
        return new Uint8Array(chunk);
    return chunk;
}
function concat(chunks) {
    const arrays = chunks.map(chunk => ensureTypedArray(chunk));
    const len = arrays.reduce((prev, arr) => prev + arr.byteLength, 0);
    const ret = new Uint8Array(len);
    let offset = 0;
    for (let arr of arrays) {
        ret.set(new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength), offset);
        offset += arr.byteLength;
    }
    return ret;
}
function streamHeadWhatwg(readable, bytes) {
    return new Promise((resolve, reject) => {
        let bytesRead = 0;
        let isComplete = false;
        const chunks = [];
        const reader = readable.getReader();
        function complete() {
            /* istanbul ignore next */
            if (isComplete)
                return null;
            isComplete = true;
        }
        (async () => {
            while (true) {
                const { done, value: chunk } = await reader.read();
                if (done) {
                    complete();
                    break;
                }
                else {
                    if (!isDataChunk(chunk))
                        throw new TypeError("Expecting chunk to be a typed array");
                    bytesRead += chunk.byteLength;
                    chunks.push(chunk);
                    if (bytesRead >= bytes) {
                        complete();
                        break;
                    }
                }
            }
            resolve({
                head: concat(chunks),
                stream: new ReadableStream({
                    start() { },
                    async pull(controller) {
                        if (chunks.length > 0) {
                            chunks.forEach(chunk => controller.enqueue(chunk));
                            chunks.length = 0;
                            return;
                        }
                        const { done, value } = await reader.read();
                        if (done)
                            controller.close();
                        else
                            controller.enqueue(value);
                    }
                }),
            });
        })()
            .catch(reject);
    });
}
function streamHeadNode(readable, bytes) {
    return new Promise((resolve, reject) => {
        const headStream = through2(onChunk, onEnd);
        const outputStream = through2();
        let bytesRead = 0;
        let isComplete = false;
        const chunks = [];
        function complete() {
            if (isComplete)
                return null;
            isComplete = true;
            const head = Buffer.concat(chunks);
            resolve({
                head: new Uint8Array(head),
                stream: outputStream,
            });
            chunks.length = 0;
            return head;
        }
        function onChunk(chunk, encoding, callback) {
            if (!isComplete) {
                chunks.push(chunk);
                bytesRead += chunk.length;
                if (bytesRead >= bytes)
                    this.push(complete());
                return callback();
            }
            else {
                this.push(chunk);
                return callback();
            }
        }
        function onEnd(callback) {
            const head = complete();
            if (head)
                this.push(head);
            return callback();
        }
        headStream.once('error', reject);
        readable.pipe(headStream).pipe(outputStream);
    });
}
