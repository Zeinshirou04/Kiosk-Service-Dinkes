import { RUNTIME } from "../runtime";
import { Blob } from "formdata-node";
class FormDataRequestBody {
    fd;
    encoder;
    constructor(fd) {
        this.fd = fd;
    }
    async setup() {
        if (this.encoder == null && RUNTIME.type === "node") {
            this.encoder = new (await import("form-data-encoder")).FormDataEncoder(this.fd);
        }
    }
    async needsEncoder() {
        if (RUNTIME.type !== "node") {
            return false;
        }
        try {
            return (await import("node:stream")).Readable !== undefined;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * @returns the multipart form data request
     */
    async getBody() {
        if (!(await this.needsEncoder())) {
            return this.fd;
        }
        else {
            if (this.encoder == null) {
                await this.setup();
            }
            return (await import("node:stream")).Readable.from(this.encoder);
        }
    }
    /**
     * @returns headers that need to be added to the multipart form data request
     */
    async getHeaders() {
        if (!(await this.needsEncoder())) {
            return {};
        }
        else {
            if (this.encoder == null) {
                await this.setup();
            }
            return {
                ...this.encoder.headers,
                "Content-Length": this.encoder.length,
            };
        }
    }
}
/**
 * FormDataWrapper is a utility to make form data
 * requests across both Browser and Node.js runtimes.
 */
export class FormDataWrapper {
    fd;
    async append(name, value) {
        if (this.fd == null) {
            this.fd = new (await import("formdata-node")).FormData();
        }
        if (name === "options" && typeof value === "string") {
            this.fd.append("options", new Blob([value], { type: "application/json" }));
            return;
        }
        try {
            const Readable = (await import("stream")).Readable;
            if (RUNTIME.type === "node" && value instanceof Readable) {
                const { stream, mime } = await (await import("stream-mime-type")).getMimeType(value);
                // If there is no filename, generate a random one. This is especially useful for multiple file operations that don't rely on filenames.
                let fileName = ((Math.random() + 1).toString(36) + "00000000000000000").slice(2, 7);
                this.fd.append(name, {
                    type: mime,
                    name: fileName,
                    [Symbol.toStringTag]: "File",
                    stream() {
                        return stream;
                    },
                });
                return;
            }
        }
        catch (e) { }
        this.fd.append(name, value);
    }
    getRequest() {
        return new FormDataRequestBody(this.fd);
    }
}
//# sourceMappingURL=FormDataWrapper.js.map