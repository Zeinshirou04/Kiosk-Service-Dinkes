{
  "version": 3,
  "sources": ["../../@fileforge/client/dist/esm/client/codegen/core/schemas/client/codegen/core/schemas/index.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/client/codegen/core/schemas/Schema.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/utils/client/codegen/core/schemas/utils/getErrorMessageForIncorrectType.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/utils/client/codegen/core/schemas/utils/maybeSkipValidation.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/schema-utils/client/codegen/core/schemas/builders/schema-utils/stringifyValidationErrors.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/schema-utils/client/codegen/core/schemas/builders/schema-utils/JsonError.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/schema-utils/client/codegen/core/schemas/builders/schema-utils/ParseError.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/schema-utils/client/codegen/core/schemas/builders/schema-utils/getSchemaUtils.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/date/client/codegen/core/schemas/builders/date/date.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/utils/client/codegen/core/schemas/utils/createIdentitySchemaCreator.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/enum/client/codegen/core/schemas/builders/enum/enum.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/lazy/client/codegen/core/schemas/builders/lazy/lazy.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/utils/client/codegen/core/schemas/utils/entries.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/utils/client/codegen/core/schemas/utils/filterObject.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/utils/client/codegen/core/schemas/utils/isPlainObject.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/utils/client/codegen/core/schemas/utils/keys.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/utils/client/codegen/core/schemas/utils/partition.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/object-like/client/codegen/core/schemas/builders/object-like/getObjectLikeUtils.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/object/client/codegen/core/schemas/builders/object/property.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/object/client/codegen/core/schemas/builders/object/object.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/object/client/codegen/core/schemas/builders/object/objectWithoutOptionalProperties.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/lazy/client/codegen/core/schemas/builders/lazy/lazyObject.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/list/client/codegen/core/schemas/builders/list/list.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/literals/client/codegen/core/schemas/builders/literals/stringLiteral.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/literals/client/codegen/core/schemas/builders/literals/booleanLiteral.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/primitives/client/codegen/core/schemas/builders/primitives/any.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/primitives/client/codegen/core/schemas/builders/primitives/boolean.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/primitives/client/codegen/core/schemas/builders/primitives/number.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/primitives/client/codegen/core/schemas/builders/primitives/string.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/primitives/client/codegen/core/schemas/builders/primitives/unknown.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/record/client/codegen/core/schemas/builders/record/record.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/set/client/codegen/core/schemas/builders/set/set.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/undiscriminated-union/client/codegen/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/union/client/codegen/core/schemas/builders/union/discriminant.ts", "../../@fileforge/client/dist/esm/client/codegen/core/schemas/builders/union/client/codegen/core/schemas/builders/union/union.ts"],
  "sourcesContent": ["export * from \"./builders\";\nexport type { inferParsed, inferRaw, Schema, SchemaOptions } from \"./Schema\";\n", "import { SchemaUtils } from \"./builders\";\nimport { MaybePromise } from \"./utils/MaybePromise\";\n\nexport type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;\n\nexport type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;\nexport type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;\n\nexport interface BaseSchema<Raw, Parsed> {\n    parse: (raw: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Parsed>>;\n    json: (parsed: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Raw>>;\n    getType: () => SchemaType | Promise<SchemaType>;\n}\n\nexport const SchemaType = {\n    DATE: \"date\",\n    ENUM: \"enum\",\n    LIST: \"list\",\n    STRING_LITERAL: \"stringLiteral\",\n    BOOLEAN_LITERAL: \"booleanLiteral\",\n    OBJECT: \"object\",\n    ANY: \"any\",\n    BOOLEAN: \"boolean\",\n    NUMBER: \"number\",\n    STRING: \"string\",\n    UNKNOWN: \"unknown\",\n    RECORD: \"record\",\n    SET: \"set\",\n    UNION: \"union\",\n    UNDISCRIMINATED_UNION: \"undiscriminatedUnion\",\n    OPTIONAL: \"optional\",\n} as const;\nexport type SchemaType = typeof SchemaType[keyof typeof SchemaType];\n\nexport type MaybeValid<T> = Valid<T> | Invalid;\n\nexport interface Valid<T> {\n    ok: true;\n    value: T;\n}\n\nexport interface Invalid {\n    ok: false;\n    errors: ValidationError[];\n}\n\nexport interface ValidationError {\n    path: string[];\n    message: string;\n}\n\nexport interface SchemaOptions {\n    /**\n     * how to handle unrecognized keys in objects\n     *\n     * @default \"fail\"\n     */\n    unrecognizedObjectKeys?: \"fail\" | \"passthrough\" | \"strip\";\n\n    /**\n     * whether to fail when an unrecognized discriminant value is\n     * encountered in a union\n     *\n     * @default false\n     */\n    allowUnrecognizedUnionMembers?: boolean;\n\n    /**\n     * whether to fail when an unrecognized enum value is encountered\n     *\n     * @default false\n     */\n    allowUnrecognizedEnumValues?: boolean;\n\n    /**\n     * whether to allow data that doesn't conform to the schema.\n     * invalid data is passed through without transformation.\n     *\n     * when this is enabled, .parse() and .json() will always\n     * return `ok: true`. `.parseOrThrow()` and `.jsonOrThrow()`\n     * will never fail.\n     *\n     * @default false\n     */\n    skipValidation?: boolean;\n\n    /**\n     * each validation failure contains a \"path\" property, which is\n     * the breadcrumbs to the offending node in the JSON. you can supply\n     * a prefix that is prepended to all the errors' paths. this can be\n     * helpful for zurg's internal debug logging.\n     */\n    breadcrumbsPrefix?: string[];\n}\n", "// @ts-nocheck\n\n    export function getErrorMessageForIncorrectType(value: unknown, expectedType: string): string {\n    return `Expected ${expectedType}. Received ${getTypeAsString(value)}.`;\n}\n\nfunction getTypeAsString(value: unknown): string {\n    if (Array.isArray(value)) {\n        return \"list\";\n    }\n    if (value === null) {\n        return \"null\";\n    }\n    switch (typeof value) {\n        case \"string\":\n            return `\"${value}\"`;\n        case \"number\":\n        case \"boolean\":\n        case \"undefined\":\n            return `${value}`;\n    }\n    return typeof value;\n}\n", "// @ts-nocheck\n\n    import { BaseSchema, MaybeValid, SchemaOptions } from \"../Schema\";\nimport { MaybePromise } from \"./MaybePromise\";\n\nexport function maybeSkipValidation<S extends BaseSchema<Raw, Parsed>, Raw, Parsed>(schema: S): S {\n    return {\n        ...schema,\n        json: transformAndMaybeSkipValidation(schema.json),\n        parse: transformAndMaybeSkipValidation(schema.parse),\n    };\n}\n\nfunction transformAndMaybeSkipValidation<T>(\n    transform: (value: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<T>>\n): (value: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<T>> {\n    return async (value, opts): Promise<MaybeValid<T>> => {\n        const transformed = await transform(value, opts);\n        const { skipValidation = false } = opts ?? {};\n        if (!transformed.ok && skipValidation) {\n            // eslint-disable-next-line no-console\n            console.warn(\n                [\n                    \"Failed to validate.\",\n                    ...transformed.errors.map(\n                        (error) =>\n                            \"  - \" +\n                            (error.path.length > 0 ? `${error.path.join(\".\")}: ${error.message}` : error.message)\n                    ),\n                ].join(\"\\n\")\n            );\n\n            return {\n                ok: true,\n                value: value as T,\n            };\n        } else {\n            return transformed;\n        }\n    };\n}\n", "import { ValidationError } from \"../../Schema\";\n\nexport function stringifyValidationError(error: ValidationError): string {\n    if (error.path.length === 0) {\n        return error.message;\n    }\n    return `${error.path.join(\" -> \")}: ${error.message}`;\n}\n", "import { ValidationError } from \"../../Schema\";\nimport { stringifyValidationError } from \"./stringifyValidationErrors\";\n\nexport class JsonError extends Error {\n    constructor(public readonly errors: ValidationError[]) {\n        super(errors.map(stringifyValidationError).join(\"; \"));\n        Object.setPrototypeOf(this, JsonError.prototype);\n    }\n}\n", "import { ValidationError } from \"../../Schema\";\nimport { stringifyValidationError } from \"./stringifyValidationErrors\";\n\nexport class ParseError extends Error {\n    constructor(public readonly errors: ValidationError[]) {\n        super(errors.map(stringifyValidationError).join(\"; \"));\n        Object.setPrototypeOf(this, ParseError.prototype);\n    }\n}\n", "import { BaseSchema, Schema, SchemaOptions, SchemaType } from \"../../Schema\";\nimport { JsonError } from \"./JsonError\";\nimport { ParseError } from \"./ParseError\";\n\nexport interface SchemaUtils<Raw, Parsed> {\n    optional: () => Schema<Raw | null | undefined, Parsed | undefined>;\n    transform: <Transformed>(transformer: SchemaTransformer<Parsed, Transformed>) => Schema<Raw, Transformed>;\n    parseOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Parsed>;\n    jsonOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Raw>;\n}\n\nexport interface SchemaTransformer<Parsed, Transformed> {\n    transform: (parsed: Parsed) => Transformed;\n    untransform: (transformed: any) => Parsed;\n}\n\nexport function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {\n    return {\n        optional: () => optional(schema),\n        transform: (transformer) => transform(schema, transformer),\n        parseOrThrow: async (raw, opts) => {\n            const parsed = await schema.parse(raw, opts);\n            if (parsed.ok) {\n                return parsed.value;\n            }\n            throw new ParseError(parsed.errors);\n        },\n        jsonOrThrow: async (parsed, opts) => {\n            const raw = await schema.json(parsed, opts);\n            if (raw.ok) {\n                return raw.value;\n            }\n            throw new JsonError(raw.errors);\n        },\n    };\n}\n\n/**\n * schema utils are defined in one file to resolve issues with circular imports\n */\n\nexport function optional<Raw, Parsed>(\n    schema: BaseSchema<Raw, Parsed>\n): Schema<Raw | null | undefined, Parsed | undefined> {\n    const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {\n        parse: (raw, opts) => {\n            if (raw == null) {\n                return {\n                    ok: true,\n                    value: undefined,\n                };\n            }\n            return schema.parse(raw, opts);\n        },\n        json: (parsed, opts) => {\n            if (parsed == null) {\n                return {\n                    ok: true,\n                    value: null,\n                };\n            }\n            return schema.json(parsed, opts);\n        },\n        getType: () => SchemaType.OPTIONAL,\n    };\n\n    return {\n        ...baseSchema,\n        ...getSchemaUtils(baseSchema),\n    };\n}\n\nexport function transform<Raw, Parsed, Transformed>(\n    schema: BaseSchema<Raw, Parsed>,\n    transformer: SchemaTransformer<Parsed, Transformed>\n): Schema<Raw, Transformed> {\n    const baseSchema: BaseSchema<Raw, Transformed> = {\n        parse: async (raw, opts) => {\n            const parsed = await schema.parse(raw, opts);\n            if (!parsed.ok) {\n                return parsed;\n            }\n            return {\n                ok: true,\n                value: transformer.transform(parsed.value),\n            };\n        },\n        json: async (transformed, opts) => {\n            const parsed = await transformer.untransform(transformed);\n            return schema.json(parsed, opts);\n        },\n        getType: () => schema.getType(),\n    };\n\n    return {\n        ...baseSchema,\n        ...getSchemaUtils(baseSchema),\n    };\n}\n", "import { BaseSchema, Schema, SchemaType } from \"../../Schema\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\nimport { maybeSkipValidation } from \"../../utils/maybeSkipValidation\";\nimport { getSchemaUtils } from \"../schema-utils\";\n\n// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime\nconst ISO_8601_REGEX =\n    /^([+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([.,]\\d+(?!:))?)?(\\17[0-5]\\d([.,]\\d+)?)?([zZ]|([+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\n\nexport function date(): Schema<string, Date> {\n    const baseSchema: BaseSchema<string, Date> = {\n        parse: (raw, { breadcrumbsPrefix = [] } = {}) => {\n            if (typeof raw !== \"string\") {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: breadcrumbsPrefix,\n                            message: getErrorMessageForIncorrectType(raw, \"string\"),\n                        },\n                    ],\n                };\n            }\n            if (!ISO_8601_REGEX.test(raw)) {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: breadcrumbsPrefix,\n                            message: getErrorMessageForIncorrectType(raw, \"ISO 8601 date string\"),\n                        },\n                    ],\n                };\n            }\n            return {\n                ok: true,\n                value: new Date(raw),\n            };\n        },\n        json: (date, { breadcrumbsPrefix = [] } = {}) => {\n            if (date instanceof Date) {\n                return {\n                    ok: true,\n                    value: date.toISOString(),\n                };\n            } else {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: breadcrumbsPrefix,\n                            message: getErrorMessageForIncorrectType(date, \"Date object\"),\n                        },\n                    ],\n                };\n            }\n        },\n        getType: () => SchemaType.DATE,\n    };\n\n    return {\n        ...maybeSkipValidation(baseSchema),\n        ...getSchemaUtils(baseSchema),\n    };\n}\n", "// @ts-nocheck\n\n    import { getSchemaUtils } from \"../builders/schema-utils\";\nimport { BaseSchema, MaybeValid, Schema, SchemaOptions, SchemaType } from \"../Schema\";\nimport { maybeSkipValidation } from \"./maybeSkipValidation\";\n\nexport function createIdentitySchemaCreator<T>(\n    schemaType: SchemaType,\n    validate: (value: unknown, opts?: SchemaOptions) => MaybeValid<T>\n): () => Schema<T, T> {\n    return () => {\n        const baseSchema: BaseSchema<T, T> = {\n            parse: validate,\n            json: validate,\n            getType: () => schemaType,\n        };\n\n        return {\n            ...maybeSkipValidation(baseSchema),\n            ...getSchemaUtils(baseSchema),\n        };\n    };\n}\n", "import { Schema, SchemaType } from \"../../Schema\";\nimport { createIdentitySchemaCreator } from \"../../utils/createIdentitySchemaCreator\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\n\nexport function enum_<U extends string, E extends U[]>(values: E): Schema<E[number], E[number]> {\n    const validValues = new Set<string>(values);\n\n    const schemaCreator = createIdentitySchemaCreator(\n        SchemaType.ENUM,\n        (value, { allowUnrecognizedEnumValues, breadcrumbsPrefix = [] } = {}) => {\n            if (typeof value !== \"string\") {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: breadcrumbsPrefix,\n                            message: getErrorMessageForIncorrectType(value, \"string\"),\n                        },\n                    ],\n                };\n            }\n\n            if (!validValues.has(value) && !allowUnrecognizedEnumValues) {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: breadcrumbsPrefix,\n                            message: getErrorMessageForIncorrectType(value, \"enum\"),\n                        },\n                    ],\n                };\n            }\n\n            return {\n                ok: true,\n                value: value as U,\n            };\n        }\n    );\n\n    return schemaCreator();\n}\n", "import { BaseSchema, Schema } from \"../../Schema\";\nimport { getSchemaUtils } from \"../schema-utils\";\n\nexport type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;\n\nexport function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {\n    const baseSchema = constructLazyBaseSchema(getter);\n    return {\n        ...baseSchema,\n        ...getSchemaUtils(baseSchema),\n    };\n}\n\nexport function constructLazyBaseSchema<Raw, Parsed>(\n    getter: SchemaGetter<Schema<Raw, Parsed>>\n): BaseSchema<Raw, Parsed> {\n    return {\n        parse: async (raw, opts) => (await getMemoizedSchema(getter)).parse(raw, opts),\n        json: async (parsed, opts) => (await getMemoizedSchema(getter)).json(parsed, opts),\n        getType: async () => (await getMemoizedSchema(getter)).getType(),\n    };\n}\n\ntype MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };\n\nexport async function getMemoizedSchema<SchemaType extends Schema<any, any>>(\n    getter: SchemaGetter<SchemaType>\n): Promise<SchemaType> {\n    const castedGetter = getter as MemoizedGetter<SchemaType>;\n    if (castedGetter.__zurg_memoized == null) {\n        castedGetter.__zurg_memoized = await getter();\n    }\n    return castedGetter.__zurg_memoized;\n}\n", "// @ts-nocheck\n\n    export function entries<T>(object: T): [keyof T, T[keyof T]][] {\n    return Object.entries(object) as [keyof T, T[keyof T]][];\n}\n", "// @ts-nocheck\n\n    export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {\n    const keysToIncludeSet = new Set(keysToInclude);\n    return Object.entries(obj).reduce((acc, [key, value]) => {\n        if (keysToIncludeSet.has(key as K)) {\n            acc[key as K] = value;\n        }\n        return acc;\n        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter\n    }, {} as Pick<T, K>);\n}\n", "// @ts-nocheck\n\n    // borrowed from https://github.com/lodash/lodash/blob/master/isPlainObject.js\nexport function isPlainObject(value: unknown): value is Record<string, unknown> {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n\n    return Object.getPrototypeOf(value) === proto;\n}\n", "// @ts-nocheck\n\n    export function keys<T>(object: T): (keyof T)[] {\n    return Object.keys(object) as (keyof T)[];\n}\n", "// @ts-nocheck\n\n    export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {\n    const trueItems: T[] = [],\n        falseItems: T[] = [];\n    for (const item of items) {\n        if (predicate(item)) {\n            trueItems.push(item);\n        } else {\n            falseItems.push(item);\n        }\n    }\n    return [trueItems, falseItems];\n}\n", "import { BaseSchema } from \"../../Schema\";\nimport { filterObject } from \"../../utils/filterObject\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\nimport { isPlainObject } from \"../../utils/isPlainObject\";\nimport { getSchemaUtils } from \"../schema-utils\";\nimport { ObjectLikeSchema, ObjectLikeUtils } from \"./types\";\n\nexport function getObjectLikeUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): ObjectLikeUtils<Raw, Parsed> {\n    return {\n        withParsedProperties: (properties) => withParsedProperties(schema, properties),\n    };\n}\n\n/**\n * object-like utils are defined in one file to resolve issues with circular imports\n */\n\nexport function withParsedProperties<RawObjectShape, ParsedObjectShape, Properties>(\n    objectLike: BaseSchema<RawObjectShape, ParsedObjectShape>,\n    properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }\n): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {\n    const objectSchema: BaseSchema<RawObjectShape, ParsedObjectShape & Properties> = {\n        parse: async (raw, opts) => {\n            const parsedObject = await objectLike.parse(raw, opts);\n            if (!parsedObject.ok) {\n                return parsedObject;\n            }\n\n            const additionalProperties = Object.entries(properties).reduce<Record<string, any>>(\n                (processed, [key, value]) => {\n                    return {\n                        ...processed,\n                        [key]: typeof value === \"function\" ? value(parsedObject.value) : value,\n                    };\n                },\n                {}\n            );\n\n            return {\n                ok: true,\n                value: {\n                    ...parsedObject.value,\n                    ...(additionalProperties as Properties),\n                },\n            };\n        },\n\n        json: (parsed, opts) => {\n            if (!isPlainObject(parsed)) {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: opts?.breadcrumbsPrefix ?? [],\n                            message: getErrorMessageForIncorrectType(parsed, \"object\"),\n                        },\n                    ],\n                };\n            }\n\n            // strip out added properties\n            const addedPropertyKeys = new Set(Object.keys(properties));\n            const parsedWithoutAddedProperties = filterObject(\n                parsed,\n                Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key))\n            );\n\n            return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);\n        },\n\n        getType: () => objectLike.getType(),\n    };\n\n    return {\n        ...objectSchema,\n        ...getSchemaUtils(objectSchema),\n        ...getObjectLikeUtils(objectSchema),\n    };\n}\n", "import { Schema } from \"../../Schema\";\n\nexport function property<RawKey extends string, RawValue, ParsedValue>(\n    rawKey: RawKey,\n    valueSchema: Schema<RawValue, ParsedValue>\n): Property<RawKey, RawValue, ParsedValue> {\n    return {\n        rawKey,\n        valueSchema,\n        isProperty: true,\n    };\n}\n\nexport interface Property<RawKey extends string, RawValue, ParsedValue> {\n    rawKey: RawKey;\n    valueSchema: Schema<RawValue, ParsedValue>;\n    isProperty: true;\n}\n\nexport function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return (maybeProperty as O).isProperty;\n}\n", "import { MaybeValid, Schema, SchemaType, ValidationError } from \"../../Schema\";\nimport { entries } from \"../../utils/entries\";\nimport { filterObject } from \"../../utils/filterObject\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\nimport { isPlainObject } from \"../../utils/isPlainObject\";\nimport { keys } from \"../../utils/keys\";\nimport { MaybePromise } from \"../../utils/MaybePromise\";\nimport { maybeSkipValidation } from \"../../utils/maybeSkipValidation\";\nimport { partition } from \"../../utils/partition\";\nimport { getObjectLikeUtils } from \"../object-like\";\nimport { getSchemaUtils } from \"../schema-utils\";\nimport { isProperty } from \"./property\";\nimport {\n    BaseObjectSchema,\n    inferObjectSchemaFromPropertySchemas,\n    inferParsedObjectFromPropertySchemas,\n    inferRawObjectFromPropertySchemas,\n    ObjectSchema,\n    ObjectUtils,\n    PropertySchemas,\n} from \"./types\";\n\ninterface ObjectPropertyWithRawKey {\n    rawKey: string;\n    parsedKey: string;\n    valueSchema: Schema<any, any>;\n}\n\nexport function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(\n    schemas: T\n): inferObjectSchemaFromPropertySchemas<T> {\n    const baseSchema: BaseObjectSchema<\n        inferRawObjectFromPropertySchemas<T>,\n        inferParsedObjectFromPropertySchemas<T>\n    > = {\n        _getRawProperties: () =>\n            Promise.resolve(\n                Object.entries(schemas).map(([parsedKey, propertySchema]) =>\n                    isProperty(propertySchema) ? propertySchema.rawKey : parsedKey\n                ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]\n            ),\n        _getParsedProperties: () =>\n            Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),\n\n        parse: async (raw, opts) => {\n            const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};\n            const requiredKeys: string[] = [];\n\n            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {\n                const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;\n                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)\n                    ? schemaOrObjectProperty.valueSchema\n                    : schemaOrObjectProperty;\n\n                const property: ObjectPropertyWithRawKey = {\n                    rawKey,\n                    parsedKey: parsedKey as string,\n                    valueSchema,\n                };\n\n                rawKeyToProperty[rawKey] = property;\n\n                if (isSchemaRequired(valueSchema)) {\n                    requiredKeys.push(rawKey);\n                }\n            }\n\n            return validateAndTransformObject({\n                value: raw,\n                requiredKeys,\n                getProperty: (rawKey) => {\n                    const property = rawKeyToProperty[rawKey];\n                    if (property == null) {\n                        return undefined;\n                    }\n                    return {\n                        transformedKey: property.parsedKey,\n                        transform: (propertyValue) =>\n                            property.valueSchema.parse(propertyValue, {\n                                ...opts,\n                                breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), rawKey],\n                            }),\n                    };\n                },\n                unrecognizedObjectKeys: opts?.unrecognizedObjectKeys,\n                skipValidation: opts?.skipValidation,\n                breadcrumbsPrefix: opts?.breadcrumbsPrefix,\n            });\n        },\n\n        json: async (parsed, opts) => {\n            const requiredKeys: string[] = [];\n\n            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {\n                const valueSchema: Schema<any, any> = isProperty(schemaOrObjectProperty)\n                    ? schemaOrObjectProperty.valueSchema\n                    : schemaOrObjectProperty;\n\n                if (isSchemaRequired(valueSchema)) {\n                    requiredKeys.push(parsedKey as string);\n                }\n            }\n\n            return validateAndTransformObject({\n                value: parsed,\n                requiredKeys,\n                getProperty: (\n                    parsedKey\n                ):\n                    | { transformedKey: string; transform: (propertyValue: unknown) => MaybePromise<MaybeValid<any>> }\n                    | undefined => {\n                    const property = schemas[parsedKey as keyof T];\n\n                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                    if (property == null) {\n                        return undefined;\n                    }\n\n                    if (isProperty(property)) {\n                        return {\n                            transformedKey: property.rawKey,\n                            transform: (propertyValue) =>\n                                property.valueSchema.json(propertyValue, {\n                                    ...opts,\n                                    breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), parsedKey],\n                                }),\n                        };\n                    } else {\n                        return {\n                            transformedKey: parsedKey,\n                            transform: (propertyValue) =>\n                                property.json(propertyValue, {\n                                    ...opts,\n                                    breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), parsedKey],\n                                }),\n                        };\n                    }\n                },\n                unrecognizedObjectKeys: opts?.unrecognizedObjectKeys,\n                skipValidation: opts?.skipValidation,\n                breadcrumbsPrefix: opts?.breadcrumbsPrefix,\n            });\n        },\n\n        getType: () => SchemaType.OBJECT,\n    };\n\n    return {\n        ...maybeSkipValidation(baseSchema),\n        ...getSchemaUtils(baseSchema),\n        ...getObjectLikeUtils(baseSchema),\n        ...getObjectUtils(baseSchema),\n    };\n}\n\nasync function validateAndTransformObject<Transformed>({\n    value,\n    requiredKeys,\n    getProperty,\n    unrecognizedObjectKeys = \"fail\",\n    skipValidation = false,\n    breadcrumbsPrefix = [],\n}: {\n    value: unknown;\n    requiredKeys: string[];\n    getProperty: (\n        preTransformedKey: string\n    ) => { transformedKey: string; transform: (propertyValue: unknown) => MaybePromise<MaybeValid<any>> } | undefined;\n    unrecognizedObjectKeys: \"fail\" | \"passthrough\" | \"strip\" | undefined;\n    skipValidation: boolean | undefined;\n    breadcrumbsPrefix: string[] | undefined;\n}): Promise<MaybeValid<Transformed>> {\n    if (!isPlainObject(value)) {\n        return {\n            ok: false,\n            errors: [\n                {\n                    path: breadcrumbsPrefix,\n                    message: getErrorMessageForIncorrectType(value, \"object\"),\n                },\n            ],\n        };\n    }\n\n    const missingRequiredKeys = new Set(requiredKeys);\n    const errors: ValidationError[] = [];\n    const transformed: Record<string | number | symbol, any> = {};\n\n    for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {\n        const property = getProperty(preTransformedKey);\n\n        if (property != null) {\n            missingRequiredKeys.delete(preTransformedKey);\n\n            const value = await property.transform(preTransformedItemValue);\n            if (value.ok) {\n                transformed[property.transformedKey] = value.value;\n            } else {\n                transformed[preTransformedKey] = preTransformedItemValue;\n                errors.push(...value.errors);\n            }\n        } else {\n            switch (unrecognizedObjectKeys) {\n                case \"fail\":\n                    errors.push({\n                        path: [...breadcrumbsPrefix, preTransformedKey],\n                        message: `Unexpected key \"${preTransformedKey}\"`,\n                    });\n                    break;\n                case \"strip\":\n                    break;\n                case \"passthrough\":\n                    transformed[preTransformedKey] = preTransformedItemValue;\n                    break;\n            }\n        }\n    }\n\n    errors.push(\n        ...requiredKeys\n            .filter((key) => missingRequiredKeys.has(key))\n            .map((key) => ({\n                path: breadcrumbsPrefix,\n                message: `Missing required key \"${key}\"`,\n            }))\n    );\n\n    if (errors.length === 0 || skipValidation) {\n        return {\n            ok: true,\n            value: transformed as Transformed,\n        };\n    } else {\n        return {\n            ok: false,\n            errors,\n        };\n    }\n}\n\nexport function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {\n    return {\n        extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {\n            const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {\n                _getParsedProperties: async () => [\n                    ...(await schema._getParsedProperties()),\n                    ...(await extension._getParsedProperties()),\n                ],\n                _getRawProperties: async () => [\n                    ...(await schema._getRawProperties()),\n                    ...(await extension._getRawProperties()),\n                ],\n                parse: async (raw, opts) => {\n                    return validateAndTransformExtendedObject({\n                        extensionKeys: await extension._getRawProperties(),\n                        value: raw,\n                        transformBase: (rawBase) => schema.parse(rawBase, opts),\n                        transformExtension: (rawExtension) => extension.parse(rawExtension, opts),\n                    });\n                },\n                json: async (parsed, opts) => {\n                    return validateAndTransformExtendedObject({\n                        extensionKeys: await extension._getParsedProperties(),\n                        value: parsed,\n                        transformBase: (parsedBase) => schema.json(parsedBase, opts),\n                        transformExtension: (parsedExtension) => extension.json(parsedExtension, opts),\n                    });\n                },\n                getType: () => SchemaType.OBJECT,\n            };\n\n            return {\n                ...baseSchema,\n                ...getSchemaUtils(baseSchema),\n                ...getObjectLikeUtils(baseSchema),\n                ...getObjectUtils(baseSchema),\n            };\n        },\n    };\n}\n\nasync function validateAndTransformExtendedObject<PreTransformedExtension, TransformedBase, TransformedExtension>({\n    extensionKeys,\n    value,\n    transformBase,\n    transformExtension,\n}: {\n    extensionKeys: (keyof PreTransformedExtension)[];\n    value: unknown;\n    transformBase: (value: unknown) => MaybePromise<MaybeValid<TransformedBase>>;\n    transformExtension: (value: unknown) => MaybePromise<MaybeValid<TransformedExtension>>;\n}): Promise<MaybeValid<TransformedBase & TransformedExtension>> {\n    const extensionPropertiesSet = new Set(extensionKeys);\n    const [extensionProperties, baseProperties] = partition(keys(value), (key) =>\n        extensionPropertiesSet.has(key as keyof PreTransformedExtension)\n    );\n\n    const transformedBase = await transformBase(filterObject(value, baseProperties));\n    const transformedExtension = await transformExtension(filterObject(value, extensionProperties));\n\n    if (transformedBase.ok && transformedExtension.ok) {\n        return {\n            ok: true,\n            value: {\n                ...transformedBase.value,\n                ...transformedExtension.value,\n            },\n        };\n    } else {\n        return {\n            ok: false,\n            errors: [\n                ...(transformedBase.ok ? [] : transformedBase.errors),\n                ...(transformedExtension.ok ? [] : transformedExtension.errors),\n            ],\n        };\n    }\n}\n\nfunction isSchemaRequired(schema: Schema<any, any>): boolean {\n    return !isSchemaOptional(schema);\n}\n\nfunction isSchemaOptional(schema: Schema<any, any>): boolean {\n    switch (schema.getType()) {\n        case SchemaType.ANY:\n        case SchemaType.UNKNOWN:\n        case SchemaType.OPTIONAL:\n            return true;\n        default:\n            return false;\n    }\n}\n", "import { object } from \"./object\";\nimport { inferParsedPropertySchema, inferRawObjectFromPropertySchemas, ObjectSchema, PropertySchemas } from \"./types\";\n\nexport function objectWithoutOptionalProperties<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(\n    schemas: T\n): inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas<T> {\n    return object(schemas) as unknown as inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas<T>;\n}\n\nexport type inferObjectWithoutOptionalPropertiesSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> =\n    ObjectSchema<\n        inferRawObjectFromPropertySchemas<T>,\n        inferParsedObjectWithoutOptionalPropertiesFromPropertySchemas<T>\n    >;\n\nexport type inferParsedObjectWithoutOptionalPropertiesFromPropertySchemas<T extends PropertySchemas<keyof T>> = {\n    [K in keyof T]: inferParsedPropertySchema<T[K]>;\n};\n", "import { getObjectUtils } from \"../object\";\nimport { getObjectLikeUtils } from \"../object-like\";\nimport { BaseObjectSchema, ObjectSchema } from \"../object/types\";\nimport { getSchemaUtils } from \"../schema-utils\";\nimport { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \"./lazy\";\n\nexport function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {\n    const baseSchema: BaseObjectSchema<Raw, Parsed> = {\n        ...constructLazyBaseSchema(getter),\n        _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),\n        _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),\n    };\n\n    return {\n        ...baseSchema,\n        ...getSchemaUtils(baseSchema),\n        ...getObjectLikeUtils(baseSchema),\n        ...getObjectUtils(baseSchema),\n    };\n}\n", "import { BaseSchema, MaybeValid, Schema, SchemaType, ValidationError } from \"../../Schema\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\nimport { MaybePromise } from \"../../utils/MaybePromise\";\nimport { maybeSkipValidation } from \"../../utils/maybeSkipValidation\";\nimport { getSchemaUtils } from \"../schema-utils\";\n\nexport function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {\n    const baseSchema: BaseSchema<Raw[], Parsed[]> = {\n        parse: async (raw, opts) =>\n            validateAndTransformArray(raw, (item, index) =>\n                schema.parse(item, {\n                    ...opts,\n                    breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `[${index}]`],\n                })\n            ),\n        json: (parsed, opts) =>\n            validateAndTransformArray(parsed, (item, index) =>\n                schema.json(item, {\n                    ...opts,\n                    breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `[${index}]`],\n                })\n            ),\n        getType: () => SchemaType.LIST,\n    };\n\n    return {\n        ...maybeSkipValidation(baseSchema),\n        ...getSchemaUtils(baseSchema),\n    };\n}\n\nasync function validateAndTransformArray<Raw, Parsed>(\n    value: unknown,\n    transformItem: (item: Raw, index: number) => MaybePromise<MaybeValid<Parsed>>\n): Promise<MaybeValid<Parsed[]>> {\n    if (!Array.isArray(value)) {\n        return {\n            ok: false,\n            errors: [\n                {\n                    message: getErrorMessageForIncorrectType(value, \"list\"),\n                    path: [],\n                },\n            ],\n        };\n    }\n\n    const maybeValidItems = await Promise.all(value.map((item, index) => transformItem(item, index)));\n\n    return maybeValidItems.reduce<MaybeValid<Parsed[]>>(\n        (acc, item) => {\n            if (acc.ok && item.ok) {\n                return {\n                    ok: true,\n                    value: [...acc.value, item.value],\n                };\n            }\n\n            const errors: ValidationError[] = [];\n            if (!acc.ok) {\n                errors.push(...acc.errors);\n            }\n            if (!item.ok) {\n                errors.push(...item.errors);\n            }\n\n            return {\n                ok: false,\n                errors,\n            };\n        },\n        { ok: true, value: [] }\n    );\n}\n", "import { Schema, SchemaType } from \"../../Schema\";\nimport { createIdentitySchemaCreator } from \"../../utils/createIdentitySchemaCreator\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\n\nexport function stringLiteral<V extends string>(literal: V): Schema<V, V> {\n    const schemaCreator = createIdentitySchemaCreator(\n        SchemaType.STRING_LITERAL,\n        (value, { breadcrumbsPrefix = [] } = {}) => {\n            if (value === literal) {\n                return {\n                    ok: true,\n                    value: literal,\n                };\n            } else {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: breadcrumbsPrefix,\n                            message: getErrorMessageForIncorrectType(value, `\"${literal}\"`),\n                        },\n                    ],\n                };\n            }\n        }\n    );\n\n    return schemaCreator();\n}\n", "import { Schema, SchemaType } from \"../../Schema\";\nimport { createIdentitySchemaCreator } from \"../../utils/createIdentitySchemaCreator\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\n\nexport function booleanLiteral<V extends boolean>(literal: V): Schema<V, V> {\n    const schemaCreator = createIdentitySchemaCreator(\n        SchemaType.BOOLEAN_LITERAL,\n        (value, { breadcrumbsPrefix = [] } = {}) => {\n            if (value === literal) {\n                return {\n                    ok: true,\n                    value: literal,\n                };\n            } else {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: breadcrumbsPrefix,\n                            message: getErrorMessageForIncorrectType(value, `${literal.toString()}`),\n                        },\n                    ],\n                };\n            }\n        }\n    );\n\n    return schemaCreator();\n}\n", "import { SchemaType } from \"../../Schema\";\nimport { createIdentitySchemaCreator } from \"../../utils/createIdentitySchemaCreator\";\n\nexport const any = createIdentitySchemaCreator<any>(SchemaType.ANY, (value) => ({ ok: true, value }));\n", "import { SchemaType } from \"../../Schema\";\nimport { createIdentitySchemaCreator } from \"../../utils/createIdentitySchemaCreator\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\n\nexport const boolean = createIdentitySchemaCreator<boolean>(\n    SchemaType.BOOLEAN,\n    (value, { breadcrumbsPrefix = [] } = {}) => {\n        if (typeof value === \"boolean\") {\n            return {\n                ok: true,\n                value,\n            };\n        } else {\n            return {\n                ok: false,\n                errors: [\n                    {\n                        path: breadcrumbsPrefix,\n                        message: getErrorMessageForIncorrectType(value, \"boolean\"),\n                    },\n                ],\n            };\n        }\n    }\n);\n", "import { SchemaType } from \"../../Schema\";\nimport { createIdentitySchemaCreator } from \"../../utils/createIdentitySchemaCreator\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\n\nexport const number = createIdentitySchemaCreator<number>(\n    SchemaType.NUMBER,\n    (value, { breadcrumbsPrefix = [] } = {}) => {\n        if (typeof value === \"number\") {\n            return {\n                ok: true,\n                value,\n            };\n        } else {\n            return {\n                ok: false,\n                errors: [\n                    {\n                        path: breadcrumbsPrefix,\n                        message: getErrorMessageForIncorrectType(value, \"number\"),\n                    },\n                ],\n            };\n        }\n    }\n);\n", "import { SchemaType } from \"../../Schema\";\nimport { createIdentitySchemaCreator } from \"../../utils/createIdentitySchemaCreator\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\n\nexport const string = createIdentitySchemaCreator<string>(\n    SchemaType.STRING,\n    (value, { breadcrumbsPrefix = [] } = {}) => {\n        if (typeof value === \"string\") {\n            return {\n                ok: true,\n                value,\n            };\n        } else {\n            return {\n                ok: false,\n                errors: [\n                    {\n                        path: breadcrumbsPrefix,\n                        message: getErrorMessageForIncorrectType(value, \"string\"),\n                    },\n                ],\n            };\n        }\n    }\n);\n", "import { SchemaType } from \"../../Schema\";\nimport { createIdentitySchemaCreator } from \"../../utils/createIdentitySchemaCreator\";\n\nexport const unknown = createIdentitySchemaCreator<unknown>(SchemaType.UNKNOWN, (value) => ({ ok: true, value }));\n", "import { MaybeValid, Schema, SchemaType, ValidationError } from \"../../Schema\";\nimport { entries } from \"../../utils/entries\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\nimport { isPlainObject } from \"../../utils/isPlainObject\";\nimport { MaybePromise } from \"../../utils/MaybePromise\";\nimport { maybeSkipValidation } from \"../../utils/maybeSkipValidation\";\nimport { getSchemaUtils } from \"../schema-utils\";\nimport { BaseRecordSchema, RecordSchema } from \"./types\";\n\nexport function record<RawKey extends string | number, RawValue, ParsedValue, ParsedKey extends string | number>(\n    keySchema: Schema<RawKey, ParsedKey>,\n    valueSchema: Schema<RawValue, ParsedValue>\n): RecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> {\n    const baseSchema: BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> = {\n        parse: async (raw, opts) => {\n            return validateAndTransformRecord({\n                value: raw,\n                isKeyNumeric: (await keySchema.getType()) === SchemaType.NUMBER,\n                transformKey: (key) =>\n                    keySchema.parse(key, {\n                        ...opts,\n                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key} (key)`],\n                    }),\n                transformValue: (value, key) =>\n                    valueSchema.parse(value, {\n                        ...opts,\n                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key}`],\n                    }),\n                breadcrumbsPrefix: opts?.breadcrumbsPrefix,\n            });\n        },\n        json: async (parsed, opts) => {\n            return validateAndTransformRecord({\n                value: parsed,\n                isKeyNumeric: (await keySchema.getType()) === SchemaType.NUMBER,\n                transformKey: (key) =>\n                    keySchema.json(key, {\n                        ...opts,\n                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key} (key)`],\n                    }),\n                transformValue: (value, key) =>\n                    valueSchema.json(value, {\n                        ...opts,\n                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), `${key}`],\n                    }),\n                breadcrumbsPrefix: opts?.breadcrumbsPrefix,\n            });\n        },\n        getType: () => SchemaType.RECORD,\n    };\n\n    return {\n        ...maybeSkipValidation(baseSchema),\n        ...getSchemaUtils(baseSchema),\n    };\n}\n\nasync function validateAndTransformRecord<TransformedKey extends string | number, TransformedValue>({\n    value,\n    isKeyNumeric,\n    transformKey,\n    transformValue,\n    breadcrumbsPrefix = [],\n}: {\n    value: unknown;\n    isKeyNumeric: boolean;\n    transformKey: (key: string | number) => MaybePromise<MaybeValid<TransformedKey>>;\n    transformValue: (value: unknown, key: string | number) => MaybePromise<MaybeValid<TransformedValue>>;\n    breadcrumbsPrefix: string[] | undefined;\n}): Promise<MaybeValid<Record<TransformedKey, TransformedValue>>> {\n    if (!isPlainObject(value)) {\n        return {\n            ok: false,\n            errors: [\n                {\n                    path: breadcrumbsPrefix,\n                    message: getErrorMessageForIncorrectType(value, \"object\"),\n                },\n            ],\n        };\n    }\n\n    return entries(value).reduce<Promise<MaybeValid<Record<TransformedKey, TransformedValue>>>>(\n        async (accPromise, [stringKey, value]) => {\n            // skip nullish keys\n            if (value == null) {\n                return accPromise;\n            }\n\n            const acc = await accPromise;\n\n            let key: string | number = stringKey;\n            if (isKeyNumeric) {\n                const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;\n                if (!isNaN(numberKey)) {\n                    key = numberKey;\n                }\n            }\n            const transformedKey = await transformKey(key);\n\n            const transformedValue = await transformValue(value, key);\n\n            if (acc.ok && transformedKey.ok && transformedValue.ok) {\n                return {\n                    ok: true,\n                    value: {\n                        ...acc.value,\n                        [transformedKey.value]: transformedValue.value,\n                    },\n                };\n            }\n\n            const errors: ValidationError[] = [];\n            if (!acc.ok) {\n                errors.push(...acc.errors);\n            }\n            if (!transformedKey.ok) {\n                errors.push(...transformedKey.errors);\n            }\n            if (!transformedValue.ok) {\n                errors.push(...transformedValue.errors);\n            }\n\n            return {\n                ok: false,\n                errors,\n            };\n        },\n        Promise.resolve({ ok: true, value: {} as Record<TransformedKey, TransformedValue> })\n    );\n}\n", "import { BaseSchema, Schema, SchemaType } from \"../../Schema\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\nimport { maybeSkipValidation } from \"../../utils/maybeSkipValidation\";\nimport { list } from \"../list\";\nimport { getSchemaUtils } from \"../schema-utils\";\n\nexport function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {\n    const listSchema = list(schema);\n    const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {\n        parse: async (raw, opts) => {\n            const parsedList = await listSchema.parse(raw, opts);\n            if (parsedList.ok) {\n                return {\n                    ok: true,\n                    value: new Set(parsedList.value),\n                };\n            } else {\n                return parsedList;\n            }\n        },\n        json: async (parsed, opts) => {\n            if (!(parsed instanceof Set)) {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: opts?.breadcrumbsPrefix ?? [],\n                            message: getErrorMessageForIncorrectType(parsed, \"Set\"),\n                        },\n                    ],\n                };\n            }\n            const jsonList = await listSchema.json([...parsed], opts);\n            return jsonList;\n        },\n        getType: () => SchemaType.SET,\n    };\n\n    return {\n        ...maybeSkipValidation(baseSchema),\n        ...getSchemaUtils(baseSchema),\n    };\n}\n", "import { BaseSchema, MaybeValid, Schema, SchemaOptions, SchemaType, ValidationError } from \"../../Schema\";\nimport { MaybePromise } from \"../../utils/MaybePromise\";\nimport { maybeSkipValidation } from \"../../utils/maybeSkipValidation\";\nimport { getSchemaUtils } from \"../schema-utils\";\nimport { inferParsedUnidiscriminatedUnionSchema, inferRawUnidiscriminatedUnionSchema } from \"./types\";\n\nexport function undiscriminatedUnion<Schemas extends [Schema<any, any>, ...Schema<any, any>[]]>(\n    schemas: Schemas\n): Schema<inferRawUnidiscriminatedUnionSchema<Schemas>, inferParsedUnidiscriminatedUnionSchema<Schemas>> {\n    const baseSchema: BaseSchema<\n        inferRawUnidiscriminatedUnionSchema<Schemas>,\n        inferParsedUnidiscriminatedUnionSchema<Schemas>\n    > = {\n        parse: async (raw, opts) => {\n            return validateAndTransformUndiscriminatedUnion<inferParsedUnidiscriminatedUnionSchema<Schemas>>(\n                (schema, opts) => schema.parse(raw, opts),\n                schemas,\n                opts\n            );\n        },\n        json: async (parsed, opts) => {\n            return validateAndTransformUndiscriminatedUnion<inferRawUnidiscriminatedUnionSchema<Schemas>>(\n                (schema, opts) => schema.json(parsed, opts),\n                schemas,\n                opts\n            );\n        },\n        getType: () => SchemaType.UNDISCRIMINATED_UNION,\n    };\n\n    return {\n        ...maybeSkipValidation(baseSchema),\n        ...getSchemaUtils(baseSchema),\n    };\n}\n\nasync function validateAndTransformUndiscriminatedUnion<Transformed>(\n    transform: (schema: Schema<any, any>, opts: SchemaOptions) => MaybePromise<MaybeValid<Transformed>>,\n    schemas: Schema<any, any>[],\n    opts: SchemaOptions | undefined\n): Promise<MaybeValid<Transformed>> {\n    const errors: ValidationError[] = [];\n    for (const [index, schema] of schemas.entries()) {\n        const transformed = await transform(schema, { ...opts, skipValidation: false });\n        if (transformed.ok) {\n            return transformed;\n        } else {\n            for (const error of transformed.errors) {\n                errors.push({\n                    path: error.path,\n                    message: `[Variant ${index}] ${error.message}`,\n                });\n            }\n        }\n    }\n\n    return {\n        ok: false,\n        errors,\n    };\n}\n", "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(\n    parsedDiscriminant: ParsedDiscriminant,\n    rawDiscriminant: RawDiscriminant\n): Discriminant<RawDiscriminant, ParsedDiscriminant> {\n    return {\n        parsedDiscriminant,\n        rawDiscriminant,\n    };\n}\n\nexport interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {\n    parsedDiscriminant: ParsedDiscriminant;\n    rawDiscriminant: RawDiscriminant;\n}\n", "import { BaseSchema, MaybeValid, SchemaType } from \"../../Schema\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\nimport { isPlainObject } from \"../../utils/isPlainObject\";\nimport { keys } from \"../../utils/keys\";\nimport { MaybePromise } from \"../../utils/MaybePromise\";\nimport { maybeSkipValidation } from \"../../utils/maybeSkipValidation\";\nimport { enum_ } from \"../enum\";\nimport { ObjectSchema } from \"../object\";\nimport { getObjectLikeUtils, ObjectLikeSchema } from \"../object-like\";\nimport { getSchemaUtils } from \"../schema-utils\";\nimport { Discriminant } from \"./discriminant\";\nimport { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \"./types\";\n\nexport function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(\n    discriminant: D,\n    union: U\n): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {\n    const rawDiscriminant =\n        typeof discriminant === \"string\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);\n    const parsedDiscriminant =\n        typeof discriminant === \"string\"\n            ? discriminant\n            : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);\n\n    const discriminantValueSchema = enum_(keys(union) as string[]);\n\n    const baseSchema: BaseSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {\n        parse: async (raw, opts) => {\n            return transformAndValidateUnion({\n                value: raw,\n                discriminant: rawDiscriminant,\n                transformedDiscriminant: parsedDiscriminant,\n                transformDiscriminantValue: (discriminantValue) =>\n                    discriminantValueSchema.parse(discriminantValue, {\n                        allowUnrecognizedEnumValues: opts?.allowUnrecognizedUnionMembers,\n                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), rawDiscriminant],\n                    }),\n                getAdditionalPropertiesSchema: (discriminantValue) => union[discriminantValue],\n                allowUnrecognizedUnionMembers: opts?.allowUnrecognizedUnionMembers,\n                transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema) =>\n                    additionalPropertiesSchema.parse(additionalProperties, opts),\n                breadcrumbsPrefix: opts?.breadcrumbsPrefix,\n            });\n        },\n        json: async (parsed, opts) => {\n            return transformAndValidateUnion({\n                value: parsed,\n                discriminant: parsedDiscriminant,\n                transformedDiscriminant: rawDiscriminant,\n                transformDiscriminantValue: (discriminantValue) =>\n                    discriminantValueSchema.json(discriminantValue, {\n                        allowUnrecognizedEnumValues: opts?.allowUnrecognizedUnionMembers,\n                        breadcrumbsPrefix: [...(opts?.breadcrumbsPrefix ?? []), parsedDiscriminant],\n                    }),\n                getAdditionalPropertiesSchema: (discriminantValue) => union[discriminantValue],\n                allowUnrecognizedUnionMembers: opts?.allowUnrecognizedUnionMembers,\n                transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema) =>\n                    additionalPropertiesSchema.json(additionalProperties, opts),\n                breadcrumbsPrefix: opts?.breadcrumbsPrefix,\n            });\n        },\n        getType: () => SchemaType.UNION,\n    };\n\n    return {\n        ...maybeSkipValidation(baseSchema),\n        ...getSchemaUtils(baseSchema),\n        ...getObjectLikeUtils(baseSchema),\n    };\n}\n\nasync function transformAndValidateUnion<\n    TransformedDiscriminant extends string,\n    TransformedDiscriminantValue extends string,\n    TransformedAdditionalProperties\n>({\n    value,\n    discriminant,\n    transformedDiscriminant,\n    transformDiscriminantValue,\n    getAdditionalPropertiesSchema,\n    allowUnrecognizedUnionMembers = false,\n    transformAdditionalProperties,\n    breadcrumbsPrefix = [],\n}: {\n    value: unknown;\n    discriminant: string;\n    transformedDiscriminant: TransformedDiscriminant;\n    transformDiscriminantValue: (discriminantValue: unknown) => MaybePromise<MaybeValid<TransformedDiscriminantValue>>;\n    getAdditionalPropertiesSchema: (discriminantValue: string) => ObjectSchema<any, any> | undefined;\n    allowUnrecognizedUnionMembers: boolean | undefined;\n    transformAdditionalProperties: (\n        additionalProperties: unknown,\n        additionalPropertiesSchema: ObjectSchema<any, any>\n    ) => MaybePromise<MaybeValid<TransformedAdditionalProperties>>;\n    breadcrumbsPrefix: string[] | undefined;\n}): Promise<\n    MaybeValid<Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties>\n> {\n    if (!isPlainObject(value)) {\n        return {\n            ok: false,\n            errors: [\n                {\n                    path: breadcrumbsPrefix,\n                    message: getErrorMessageForIncorrectType(value, \"object\"),\n                },\n            ],\n        };\n    }\n\n    const { [discriminant]: discriminantValue, ...additionalProperties } = value;\n\n    if (discriminantValue == null) {\n        return {\n            ok: false,\n            errors: [\n                {\n                    path: breadcrumbsPrefix,\n                    message: `Missing discriminant (\"${discriminant}\")`,\n                },\n            ],\n        };\n    }\n\n    const transformedDiscriminantValue = await transformDiscriminantValue(discriminantValue);\n    if (!transformedDiscriminantValue.ok) {\n        return {\n            ok: false,\n            errors: transformedDiscriminantValue.errors,\n        };\n    }\n\n    const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);\n\n    if (additionalPropertiesSchema == null) {\n        if (allowUnrecognizedUnionMembers) {\n            return {\n                ok: true,\n                value: {\n                    [transformedDiscriminant]: transformedDiscriminantValue.value,\n                    ...additionalProperties,\n                } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,\n            };\n        } else {\n            return {\n                ok: false,\n                errors: [\n                    {\n                        path: [...breadcrumbsPrefix, discriminant],\n                        message: \"Unexpected discriminant value\",\n                    },\n                ],\n            };\n        }\n    }\n\n    const transformedAdditionalProperties = await transformAdditionalProperties(\n        additionalProperties,\n        additionalPropertiesSchema\n    );\n    if (!transformedAdditionalProperties.ok) {\n        return transformedAdditionalProperties;\n    }\n\n    return {\n        ok: true,\n        value: {\n            [transformedDiscriminant]: discriminantValue,\n            ...transformedAdditionalProperties.value,\n        } as Record<TransformedDiscriminant, TransformedDiscriminantValue> & TransformedAdditionalProperties,\n    };\n}\n"],
  "mappings": ";;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACcO,IAAM,aAAa;EACtB,MAAM;EACN,MAAM;EACN,MAAM;EACN,gBAAgB;EAChB,iBAAiB;EACjB,QAAQ;EACR,KAAK;EACL,SAAS;EACT,QAAQ;EACR,QAAQ;EACR,SAAS;EACT,QAAQ;EACR,KAAK;EACL,OAAO;EACP,uBAAuB;EACvB,UAAU;;;;AC5BJ,SAAU,gCAAgC,OAAgB,cAAoB;AACpF,SAAO,YAAY,YAAY,cAAc,gBAAgB,KAAK,CAAC;AACvE;AAEA,SAAS,gBAAgB,OAAc;AACnC,MAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,WAAO;EACX;AACA,MAAI,UAAU,MAAM;AAChB,WAAO;EACX;AACA,UAAQ,OAAO,OAAO;IAClB,KAAK;AACD,aAAO,IAAI,KAAK;IACpB,KAAK;IACL,KAAK;IACL,KAAK;AACD,aAAO,GAAG,KAAK;EACvB;AACA,SAAO,OAAO;AAClB;;;ACjBM,SAAU,oBAAoE,QAAS;AACzF,SAAO;IACH,GAAG;IACH,MAAM,gCAAgC,OAAO,IAAI;IACjD,OAAO,gCAAgC,OAAO,KAAK;;AAE3D;AAEA,SAAS,gCACLA,YAAgF;AAEhF,SAAO,OAAO,OAAO,SAAgC;AACjD,UAAM,cAAc,MAAMA,WAAU,OAAO,IAAI;AAC/C,UAAM,EAAE,iBAAiB,MAAK,IAAK,QAAQ,CAAA;AAC3C,QAAI,CAAC,YAAY,MAAM,gBAAgB;AAEnC,cAAQ,KACJ;QACI;QACA,GAAG,YAAY,OAAO,IAClB,CAAC,UACG,UACC,MAAM,KAAK,SAAS,IAAI,GAAG,MAAM,KAAK,KAAK,GAAG,CAAC,KAAK,MAAM,OAAO,KAAK,MAAM,QAAQ;QAE/F,KAAK,IAAI,CAAC;AAGhB,aAAO;QACH,IAAI;QACJ;;IAER,OAAO;AACH,aAAO;IACX;EACJ;AACJ;;;ACtCM,SAAU,yBAAyB,OAAsB;AAC3D,MAAI,MAAM,KAAK,WAAW,GAAG;AACzB,WAAO,MAAM;EACjB;AACA,SAAO,GAAG,MAAM,KAAK,KAAK,MAAM,CAAC,KAAK,MAAM,OAAO;AACvD;;;ACJM,IAAO,YAAP,MAAO,mBAAkB,MAAK;EAChC,YAA4B,QAAyB;AACjD,UAAM,OAAO,IAAI,wBAAwB,EAAE,KAAK,IAAI,CAAC;AAD7B;AAAA,SAAA,SAAA;AAExB,WAAO,eAAe,MAAM,WAAU,SAAS;EACnD;;;;ACJE,IAAO,aAAP,MAAO,oBAAmB,MAAK;EACjC,YAA4B,QAAyB;AACjD,UAAM,OAAO,IAAI,wBAAwB,EAAE,KAAK,IAAI,CAAC;AAD7B;AAAA,SAAA,SAAA;AAExB,WAAO,eAAe,MAAM,YAAW,SAAS;EACpD;;;;ACSE,SAAU,eAA4B,QAA+B;AACvE,SAAO;IACH,UAAU,MAAM,SAAS,MAAM;IAC/B,WAAW,CAAC,gBAAgB,UAAU,QAAQ,WAAW;IACzD,cAAc,OAAO,KAAK,SAAQ;AAC9B,YAAM,SAAS,MAAM,OAAO,MAAM,KAAK,IAAI;AAC3C,UAAI,OAAO,IAAI;AACX,eAAO,OAAO;MAClB;AACA,YAAM,IAAI,WAAW,OAAO,MAAM;IACtC;IACA,aAAa,OAAO,QAAQ,SAAQ;AAChC,YAAM,MAAM,MAAM,OAAO,KAAK,QAAQ,IAAI;AAC1C,UAAI,IAAI,IAAI;AACR,eAAO,IAAI;MACf;AACA,YAAM,IAAI,UAAU,IAAI,MAAM;IAClC;;AAER;AAMM,SAAU,SACZ,QAA+B;AAE/B,QAAM,aAAqE;IACvE,OAAO,CAAC,KAAK,SAAQ;AACjB,UAAI,OAAO,MAAM;AACb,eAAO;UACH,IAAI;UACJ,OAAO;;MAEf;AACA,aAAO,OAAO,MAAM,KAAK,IAAI;IACjC;IACA,MAAM,CAAC,QAAQ,SAAQ;AACnB,UAAI,UAAU,MAAM;AAChB,eAAO;UACH,IAAI;UACJ,OAAO;;MAEf;AACA,aAAO,OAAO,KAAK,QAAQ,IAAI;IACnC;IACA,SAAS,MAAM,WAAW;;AAG9B,SAAO;IACH,GAAG;IACH,GAAG,eAAe,UAAU;;AAEpC;AAEM,SAAU,UACZ,QACA,aAAmD;AAEnD,QAAM,aAA2C;IAC7C,OAAO,OAAO,KAAK,SAAQ;AACvB,YAAM,SAAS,MAAM,OAAO,MAAM,KAAK,IAAI;AAC3C,UAAI,CAAC,OAAO,IAAI;AACZ,eAAO;MACX;AACA,aAAO;QACH,IAAI;QACJ,OAAO,YAAY,UAAU,OAAO,KAAK;;IAEjD;IACA,MAAM,OAAO,aAAa,SAAQ;AAC9B,YAAM,SAAS,MAAM,YAAY,YAAY,WAAW;AACxD,aAAO,OAAO,KAAK,QAAQ,IAAI;IACnC;IACA,SAAS,MAAM,OAAO,QAAO;;AAGjC,SAAO;IACH,GAAG;IACH,GAAG,eAAe,UAAU;;AAEpC;;;AC5FA,IAAM,iBACF;AAEE,SAAU,OAAI;AAChB,QAAM,aAAuC;IACzC,OAAO,CAAC,KAAK,EAAE,oBAAoB,CAAA,EAAE,IAAK,CAAA,MAAM;AAC5C,UAAI,OAAO,QAAQ,UAAU;AACzB,eAAO;UACH,IAAI;UACJ,QAAQ;YACJ;cACI,MAAM;cACN,SAAS,gCAAgC,KAAK,QAAQ;;;;MAItE;AACA,UAAI,CAAC,eAAe,KAAK,GAAG,GAAG;AAC3B,eAAO;UACH,IAAI;UACJ,QAAQ;YACJ;cACI,MAAM;cACN,SAAS,gCAAgC,KAAK,sBAAsB;;;;MAIpF;AACA,aAAO;QACH,IAAI;QACJ,OAAO,IAAI,KAAK,GAAG;;IAE3B;IACA,MAAM,CAACC,OAAM,EAAE,oBAAoB,CAAA,EAAE,IAAK,CAAA,MAAM;AAC5C,UAAIA,iBAAgB,MAAM;AACtB,eAAO;UACH,IAAI;UACJ,OAAOA,MAAK,YAAW;;MAE/B,OAAO;AACH,eAAO;UACH,IAAI;UACJ,QAAQ;YACJ;cACI,MAAM;cACN,SAAS,gCAAgCA,OAAM,aAAa;;;;MAI5E;IACJ;IACA,SAAS,MAAM,WAAW;;AAG9B,SAAO;IACH,GAAG,oBAAoB,UAAU;IACjC,GAAG,eAAe,UAAU;;AAEpC;;;AC1DM,SAAU,4BACZ,YACA,UAAiE;AAEjE,SAAO,MAAK;AACR,UAAM,aAA+B;MACjC,OAAO;MACP,MAAM;MACN,SAAS,MAAM;;AAGnB,WAAO;MACH,GAAG,oBAAoB,UAAU;MACjC,GAAG,eAAe,UAAU;;EAEpC;AACJ;;;AClBM,SAAU,MAAuC,QAAS;AAC5D,QAAM,cAAc,IAAI,IAAY,MAAM;AAE1C,QAAM,gBAAgB,4BAClB,WAAW,MACX,CAAC,OAAO,EAAE,6BAA6B,oBAAoB,CAAA,EAAE,IAAK,CAAA,MAAM;AACpE,QAAI,OAAO,UAAU,UAAU;AAC3B,aAAO;QACH,IAAI;QACJ,QAAQ;UACJ;YACI,MAAM;YACN,SAAS,gCAAgC,OAAO,QAAQ;;;;IAIxE;AAEA,QAAI,CAAC,YAAY,IAAI,KAAK,KAAK,CAAC,6BAA6B;AACzD,aAAO;QACH,IAAI;QACJ,QAAQ;UACJ;YACI,MAAM;YACN,SAAS,gCAAgC,OAAO,MAAM;;;;IAItE;AAEA,WAAO;MACH,IAAI;MACJ;;EAER,CAAC;AAGL,SAAO,cAAa;AACxB;;;ACrCM,SAAU,KAAkB,QAAyC;AACvE,QAAM,aAAa,wBAAwB,MAAM;AACjD,SAAO;IACH,GAAG;IACH,GAAG,eAAe,UAAU;;AAEpC;AAEM,SAAU,wBACZ,QAAyC;AAEzC,SAAO;IACH,OAAO,OAAO,KAAK,UAAU,MAAM,kBAAkB,MAAM,GAAG,MAAM,KAAK,IAAI;IAC7E,MAAM,OAAO,QAAQ,UAAU,MAAM,kBAAkB,MAAM,GAAG,KAAK,QAAQ,IAAI;IACjF,SAAS,aAAa,MAAM,kBAAkB,MAAM,GAAG,QAAO;;AAEtE;AAIA,eAAsB,kBAClB,QAAgC;AAEhC,QAAM,eAAe;AACrB,MAAI,aAAa,mBAAmB,MAAM;AACtC,iBAAa,kBAAkB,MAAM,OAAM;EAC/C;AACA,SAAO,aAAa;AACxB;;;AC/BU,SAAU,QAAWC,SAAS;AACpC,SAAO,OAAO,QAAQA,OAAM;AAChC;;;ACFU,SAAU,aAAmC,KAAQ,eAAkB;AAC7E,QAAM,mBAAmB,IAAI,IAAI,aAAa;AAC9C,SAAO,OAAO,QAAQ,GAAG,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK,KAAK,MAAK;AACpD,QAAI,iBAAiB,IAAI,GAAQ,GAAG;AAChC,UAAI,GAAQ,IAAI;IACpB;AACA,WAAO;EAEX,GAAG,CAAA,CAAgB;AACvB;;;ACRM,SAAU,cAAc,OAAc;AACxC,MAAI,OAAO,UAAU,YAAY,UAAU,MAAM;AAC7C,WAAO;EACX;AAEA,MAAI,OAAO,eAAe,KAAK,MAAM,MAAM;AACvC,WAAO;EACX;AAEA,MAAI,QAAQ;AACZ,SAAO,OAAO,eAAe,KAAK,MAAM,MAAM;AAC1C,YAAQ,OAAO,eAAe,KAAK;EACvC;AAEA,SAAO,OAAO,eAAe,KAAK,MAAM;AAC5C;;;AChBU,SAAU,KAAQC,SAAS;AACjC,SAAO,OAAO,KAAKA,OAAM;AAC7B;;;ACFU,SAAU,UAAa,OAAqB,WAA+B;AACjF,QAAM,YAAiB,CAAA,GACnB,aAAkB,CAAA;AACtB,aAAW,QAAQ,OAAO;AACtB,QAAI,UAAU,IAAI,GAAG;AACjB,gBAAU,KAAK,IAAI;IACvB,OAAO;AACH,iBAAW,KAAK,IAAI;IACxB;EACJ;AACA,SAAO,CAAC,WAAW,UAAU;AACjC;;;ACNM,SAAU,mBAAgC,QAA+B;AAC3E,SAAO;IACH,sBAAsB,CAAC,eAAe,qBAAqB,QAAQ,UAAU;;AAErF;AAMM,SAAU,qBACZ,YACA,YAAuG;AAEvG,QAAM,eAA2E;IAC7E,OAAO,OAAO,KAAK,SAAQ;AACvB,YAAM,eAAe,MAAM,WAAW,MAAM,KAAK,IAAI;AACrD,UAAI,CAAC,aAAa,IAAI;AAClB,eAAO;MACX;AAEA,YAAM,uBAAuB,OAAO,QAAQ,UAAU,EAAE,OACpD,CAAC,WAAW,CAAC,KAAK,KAAK,MAAK;AACxB,eAAO;UACH,GAAG;UACH,CAAC,GAAG,GAAG,OAAO,UAAU,aAAa,MAAM,aAAa,KAAK,IAAI;;MAEzE,GACA,CAAA,CAAE;AAGN,aAAO;QACH,IAAI;QACJ,OAAO;UACH,GAAG,aAAa;UAChB,GAAI;;;IAGhB;IAEA,MAAM,CAAC,QAAQ,SAAQ;AACnB,UAAI,CAAC,cAAc,MAAM,GAAG;AACxB,eAAO;UACH,IAAI;UACJ,QAAQ;YACJ;cACI,OAAM,6BAAM,sBAAqB,CAAA;cACjC,SAAS,gCAAgC,QAAQ,QAAQ;;;;MAIzE;AAGA,YAAM,oBAAoB,IAAI,IAAI,OAAO,KAAK,UAAU,CAAC;AACzD,YAAM,+BAA+B,aACjC,QACA,OAAO,KAAK,MAAM,EAAE,OAAO,CAAC,QAAQ,CAAC,kBAAkB,IAAI,GAAG,CAAC,CAAC;AAGpE,aAAO,WAAW,KAAK,8BAAmD,IAAI;IAClF;IAEA,SAAS,MAAM,WAAW,QAAO;;AAGrC,SAAO;IACH,GAAG;IACH,GAAG,eAAe,YAAY;IAC9B,GAAG,mBAAmB,YAAY;;AAE1C;;;AC5EM,SAAU,SACZ,QACA,aAA0C;AAE1C,SAAO;IACH;IACA;IACA,YAAY;;AAEpB;AAQM,SAAU,WAA8C,eAAsB;AAEhF,SAAQ,cAAoB;AAChC;;;ACMM,SAAU,OACZ,SAAU;AAEV,QAAM,aAGF;IACA,mBAAmB,MACf,QAAQ,QACJ,OAAO,QAAQ,OAAO,EAAE,IAAI,CAAC,CAAC,WAAW,cAAc,MACnD,WAAW,cAAc,IAAI,eAAe,SAAS,SAAS,CACJ;IAEtE,sBAAsB,MAClB,QAAQ,QAAQ,KAAK,OAAO,CAAiE;IAEjG,OAAO,OAAO,KAAK,SAAQ;AACvB,YAAM,mBAA6D,CAAA;AACnE,YAAM,eAAyB,CAAA;AAE/B,iBAAW,CAAC,WAAW,sBAAsB,KAAK,QAAQ,OAAO,GAAG;AAChE,cAAM,SAAS,WAAW,sBAAsB,IAAI,uBAAuB,SAAS;AACpF,cAAM,cAAgC,WAAW,sBAAsB,IACjE,uBAAuB,cACvB;AAEN,cAAMC,YAAqC;UACvC;UACA;UACA;;AAGJ,yBAAiB,MAAM,IAAIA;AAE3B,YAAI,iBAAiB,WAAW,GAAG;AAC/B,uBAAa,KAAK,MAAM;QAC5B;MACJ;AAEA,aAAO,2BAA2B;QAC9B,OAAO;QACP;QACA,aAAa,CAAC,WAAU;AACpB,gBAAMA,YAAW,iBAAiB,MAAM;AACxC,cAAIA,aAAY,MAAM;AAClB,mBAAO;UACX;AACA,iBAAO;YACH,gBAAgBA,UAAS;YACzB,WAAW,CAAC,kBACRA,UAAS,YAAY,MAAM,eAAe;cACtC,GAAG;cACH,mBAAmB,CAAC,IAAI,6BAAM,sBAAqB,CAAA,GAAK,MAAM;aACjE;;QAEb;QACA,wBAAwB,6BAAM;QAC9B,gBAAgB,6BAAM;QACtB,mBAAmB,6BAAM;OAC5B;IACL;IAEA,MAAM,OAAO,QAAQ,SAAQ;AACzB,YAAM,eAAyB,CAAA;AAE/B,iBAAW,CAAC,WAAW,sBAAsB,KAAK,QAAQ,OAAO,GAAG;AAChE,cAAM,cAAgC,WAAW,sBAAsB,IACjE,uBAAuB,cACvB;AAEN,YAAI,iBAAiB,WAAW,GAAG;AAC/B,uBAAa,KAAK,SAAmB;QACzC;MACJ;AAEA,aAAO,2BAA2B;QAC9B,OAAO;QACP;QACA,aAAa,CACT,cAGc;AACd,gBAAMA,YAAW,QAAQ,SAAoB;AAG7C,cAAIA,aAAY,MAAM;AAClB,mBAAO;UACX;AAEA,cAAI,WAAWA,SAAQ,GAAG;AACtB,mBAAO;cACH,gBAAgBA,UAAS;cACzB,WAAW,CAAC,kBACRA,UAAS,YAAY,KAAK,eAAe;gBACrC,GAAG;gBACH,mBAAmB,CAAC,IAAI,6BAAM,sBAAqB,CAAA,GAAK,SAAS;eACpE;;UAEb,OAAO;AACH,mBAAO;cACH,gBAAgB;cAChB,WAAW,CAAC,kBACRA,UAAS,KAAK,eAAe;gBACzB,GAAG;gBACH,mBAAmB,CAAC,IAAI,6BAAM,sBAAqB,CAAA,GAAK,SAAS;eACpE;;UAEb;QACJ;QACA,wBAAwB,6BAAM;QAC9B,gBAAgB,6BAAM;QACtB,mBAAmB,6BAAM;OAC5B;IACL;IAEA,SAAS,MAAM,WAAW;;AAG9B,SAAO;IACH,GAAG,oBAAoB,UAAU;IACjC,GAAG,eAAe,UAAU;IAC5B,GAAG,mBAAmB,UAAU;IAChC,GAAG,eAAe,UAAU;;AAEpC;AAEA,eAAe,2BAAwC,EACnD,OACA,cACA,aACA,yBAAyB,QACzB,iBAAiB,OACjB,oBAAoB,CAAA,EAAE,GAUzB;AACG,MAAI,CAAC,cAAc,KAAK,GAAG;AACvB,WAAO;MACH,IAAI;MACJ,QAAQ;QACJ;UACI,MAAM;UACN,SAAS,gCAAgC,OAAO,QAAQ;;;;EAIxE;AAEA,QAAM,sBAAsB,IAAI,IAAI,YAAY;AAChD,QAAM,SAA4B,CAAA;AAClC,QAAM,cAAqD,CAAA;AAE3D,aAAW,CAAC,mBAAmB,uBAAuB,KAAK,OAAO,QAAQ,KAAK,GAAG;AAC9E,UAAMA,YAAW,YAAY,iBAAiB;AAE9C,QAAIA,aAAY,MAAM;AAClB,0BAAoB,OAAO,iBAAiB;AAE5C,YAAMC,SAAQ,MAAMD,UAAS,UAAU,uBAAuB;AAC9D,UAAIC,OAAM,IAAI;AACV,oBAAYD,UAAS,cAAc,IAAIC,OAAM;MACjD,OAAO;AACH,oBAAY,iBAAiB,IAAI;AACjC,eAAO,KAAK,GAAGA,OAAM,MAAM;MAC/B;IACJ,OAAO;AACH,cAAQ,wBAAwB;QAC5B,KAAK;AACD,iBAAO,KAAK;YACR,MAAM,CAAC,GAAG,mBAAmB,iBAAiB;YAC9C,SAAS,mBAAmB,iBAAiB;WAChD;AACD;QACJ,KAAK;AACD;QACJ,KAAK;AACD,sBAAY,iBAAiB,IAAI;AACjC;MACR;IACJ;EACJ;AAEA,SAAO,KACH,GAAG,aACE,OAAO,CAAC,QAAQ,oBAAoB,IAAI,GAAG,CAAC,EAC5C,IAAI,CAAC,SAAS;IACX,MAAM;IACN,SAAS,yBAAyB,GAAG;IACvC,CAAC;AAGX,MAAI,OAAO,WAAW,KAAK,gBAAgB;AACvC,WAAO;MACH,IAAI;MACJ,OAAO;;EAEf,OAAO;AACH,WAAO;MACH,IAAI;MACJ;;EAER;AACJ;AAEM,SAAU,eAA4B,QAAqC;AAC7E,SAAO;IACH,QAAQ,CAAgC,cAA0D;AAC9F,YAAM,aAA6E;QAC/E,sBAAsB,YAAY;UAC9B,GAAI,MAAM,OAAO,qBAAoB;UACrC,GAAI,MAAM,UAAU,qBAAoB;;QAE5C,mBAAmB,YAAY;UAC3B,GAAI,MAAM,OAAO,kBAAiB;UAClC,GAAI,MAAM,UAAU,kBAAiB;;QAEzC,OAAO,OAAO,KAAK,SAAQ;AACvB,iBAAO,mCAAmC;YACtC,eAAe,MAAM,UAAU,kBAAiB;YAChD,OAAO;YACP,eAAe,CAAC,YAAY,OAAO,MAAM,SAAS,IAAI;YACtD,oBAAoB,CAAC,iBAAiB,UAAU,MAAM,cAAc,IAAI;WAC3E;QACL;QACA,MAAM,OAAO,QAAQ,SAAQ;AACzB,iBAAO,mCAAmC;YACtC,eAAe,MAAM,UAAU,qBAAoB;YACnD,OAAO;YACP,eAAe,CAAC,eAAe,OAAO,KAAK,YAAY,IAAI;YAC3D,oBAAoB,CAAC,oBAAoB,UAAU,KAAK,iBAAiB,IAAI;WAChF;QACL;QACA,SAAS,MAAM,WAAW;;AAG9B,aAAO;QACH,GAAG;QACH,GAAG,eAAe,UAAU;QAC5B,GAAG,mBAAmB,UAAU;QAChC,GAAG,eAAe,UAAU;;IAEpC;;AAER;AAEA,eAAe,mCAAmG,EAC9G,eACA,OACA,eACA,mBAAkB,GAMrB;AACG,QAAM,yBAAyB,IAAI,IAAI,aAAa;AACpD,QAAM,CAAC,qBAAqB,cAAc,IAAI,UAAU,KAAK,KAAK,GAAG,CAAC,QAClE,uBAAuB,IAAI,GAAoC,CAAC;AAGpE,QAAM,kBAAkB,MAAM,cAAc,aAAa,OAAO,cAAc,CAAC;AAC/E,QAAM,uBAAuB,MAAM,mBAAmB,aAAa,OAAO,mBAAmB,CAAC;AAE9F,MAAI,gBAAgB,MAAM,qBAAqB,IAAI;AAC/C,WAAO;MACH,IAAI;MACJ,OAAO;QACH,GAAG,gBAAgB;QACnB,GAAG,qBAAqB;;;EAGpC,OAAO;AACH,WAAO;MACH,IAAI;MACJ,QAAQ;QACJ,GAAI,gBAAgB,KAAK,CAAA,IAAK,gBAAgB;QAC9C,GAAI,qBAAqB,KAAK,CAAA,IAAK,qBAAqB;;;EAGpE;AACJ;AAEA,SAAS,iBAAiB,QAAwB;AAC9C,SAAO,CAAC,iBAAiB,MAAM;AACnC;AAEA,SAAS,iBAAiB,QAAwB;AAC9C,UAAQ,OAAO,QAAO,GAAI;IACtB,KAAK,WAAW;IAChB,KAAK,WAAW;IAChB,KAAK,WAAW;AACZ,aAAO;IACX;AACI,aAAO;EACf;AACJ;;;ACzUM,SAAU,gCACZ,SAAU;AAEV,SAAO,OAAO,OAAO;AACzB;;;ACDM,SAAU,WAAwB,QAA+C;AACnF,QAAM,aAA4C;IAC9C,GAAG,wBAAwB,MAAM;IACjC,mBAAmB,aAAa,MAAM,kBAAkB,MAAM,GAAG,kBAAiB;IAClF,sBAAsB,aAAa,MAAM,kBAAkB,MAAM,GAAG,qBAAoB;;AAG5F,SAAO;IACH,GAAG;IACH,GAAG,eAAe,UAAU;IAC5B,GAAG,mBAAmB,UAAU;IAChC,GAAG,eAAe,UAAU;;AAEpC;;;ACbM,SAAU,KAAkB,QAA2B;AACzD,QAAM,aAA0C;IAC5C,OAAO,OAAO,KAAK,SACf,0BAA0B,KAAK,CAAC,MAAM,UAClC,OAAO,MAAM,MAAM;MACf,GAAG;MACH,mBAAmB,CAAC,IAAI,6BAAM,sBAAqB,CAAA,GAAK,IAAI,KAAK,GAAG;KACvE,CAAC;IAEV,MAAM,CAAC,QAAQ,SACX,0BAA0B,QAAQ,CAAC,MAAM,UACrC,OAAO,KAAK,MAAM;MACd,GAAG;MACH,mBAAmB,CAAC,IAAI,6BAAM,sBAAqB,CAAA,GAAK,IAAI,KAAK,GAAG;KACvE,CAAC;IAEV,SAAS,MAAM,WAAW;;AAG9B,SAAO;IACH,GAAG,oBAAoB,UAAU;IACjC,GAAG,eAAe,UAAU;;AAEpC;AAEA,eAAe,0BACX,OACA,eAA6E;AAE7E,MAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACvB,WAAO;MACH,IAAI;MACJ,QAAQ;QACJ;UACI,SAAS,gCAAgC,OAAO,MAAM;UACtD,MAAM,CAAA;;;;EAItB;AAEA,QAAM,kBAAkB,MAAM,QAAQ,IAAI,MAAM,IAAI,CAAC,MAAM,UAAU,cAAc,MAAM,KAAK,CAAC,CAAC;AAEhG,SAAO,gBAAgB,OACnB,CAAC,KAAK,SAAQ;AACV,QAAI,IAAI,MAAM,KAAK,IAAI;AACnB,aAAO;QACH,IAAI;QACJ,OAAO,CAAC,GAAG,IAAI,OAAO,KAAK,KAAK;;IAExC;AAEA,UAAM,SAA4B,CAAA;AAClC,QAAI,CAAC,IAAI,IAAI;AACT,aAAO,KAAK,GAAG,IAAI,MAAM;IAC7B;AACA,QAAI,CAAC,KAAK,IAAI;AACV,aAAO,KAAK,GAAG,KAAK,MAAM;IAC9B;AAEA,WAAO;MACH,IAAI;MACJ;;EAER,GACA,EAAE,IAAI,MAAM,OAAO,CAAA,EAAE,CAAE;AAE/B;;;ACrEM,SAAU,cAAgC,SAAU;AACtD,QAAM,gBAAgB,4BAClB,WAAW,gBACX,CAAC,OAAO,EAAE,oBAAoB,CAAA,EAAE,IAAK,CAAA,MAAM;AACvC,QAAI,UAAU,SAAS;AACnB,aAAO;QACH,IAAI;QACJ,OAAO;;IAEf,OAAO;AACH,aAAO;QACH,IAAI;QACJ,QAAQ;UACJ;YACI,MAAM;YACN,SAAS,gCAAgC,OAAO,IAAI,OAAO,GAAG;;;;IAI9E;EACJ,CAAC;AAGL,SAAO,cAAa;AACxB;;;ACxBM,SAAU,eAAkC,SAAU;AACxD,QAAM,gBAAgB,4BAClB,WAAW,iBACX,CAAC,OAAO,EAAE,oBAAoB,CAAA,EAAE,IAAK,CAAA,MAAM;AACvC,QAAI,UAAU,SAAS;AACnB,aAAO;QACH,IAAI;QACJ,OAAO;;IAEf,OAAO;AACH,aAAO;QACH,IAAI;QACJ,QAAQ;UACJ;YACI,MAAM;YACN,SAAS,gCAAgC,OAAO,GAAG,QAAQ,SAAQ,CAAE,EAAE;;;;IAIvF;EACJ,CAAC;AAGL,SAAO,cAAa;AACxB;;;ACzBO,IAAM,MAAM,4BAAiC,WAAW,KAAK,CAAC,WAAW,EAAE,IAAI,MAAM,MAAK,EAAG;;;ACC7F,IAAM,UAAU,4BACnB,WAAW,SACX,CAAC,OAAO,EAAE,oBAAoB,CAAA,EAAE,IAAK,CAAA,MAAM;AACvC,MAAI,OAAO,UAAU,WAAW;AAC5B,WAAO;MACH,IAAI;MACJ;;EAER,OAAO;AACH,WAAO;MACH,IAAI;MACJ,QAAQ;QACJ;UACI,MAAM;UACN,SAAS,gCAAgC,OAAO,SAAS;;;;EAIzE;AACJ,CAAC;;;ACnBE,IAAM,SAAS,4BAClB,WAAW,QACX,CAAC,OAAO,EAAE,oBAAoB,CAAA,EAAE,IAAK,CAAA,MAAM;AACvC,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO;MACH,IAAI;MACJ;;EAER,OAAO;AACH,WAAO;MACH,IAAI;MACJ,QAAQ;QACJ;UACI,MAAM;UACN,SAAS,gCAAgC,OAAO,QAAQ;;;;EAIxE;AACJ,CAAC;;;ACnBE,IAAM,SAAS,4BAClB,WAAW,QACX,CAAC,OAAO,EAAE,oBAAoB,CAAA,EAAE,IAAK,CAAA,MAAM;AACvC,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO;MACH,IAAI;MACJ;;EAER,OAAO;AACH,WAAO;MACH,IAAI;MACJ,QAAQ;QACJ;UACI,MAAM;UACN,SAAS,gCAAgC,OAAO,QAAQ;;;;EAIxE;AACJ,CAAC;;;ACpBE,IAAM,UAAU,4BAAqC,WAAW,SAAS,CAAC,WAAW,EAAE,IAAI,MAAM,MAAK,EAAG;;;ACM1G,SAAU,OACZ,WACA,aAA0C;AAE1C,QAAM,aAAyE;IAC3E,OAAO,OAAO,KAAK,SAAQ;AACvB,aAAO,2BAA2B;QAC9B,OAAO;QACP,cAAe,MAAM,UAAU,QAAO,MAAQ,WAAW;QACzD,cAAc,CAAC,QACX,UAAU,MAAM,KAAK;UACjB,GAAG;UACH,mBAAmB,CAAC,IAAI,6BAAM,sBAAqB,CAAA,GAAK,GAAG,GAAG,QAAQ;SACzE;QACL,gBAAgB,CAAC,OAAO,QACpB,YAAY,MAAM,OAAO;UACrB,GAAG;UACH,mBAAmB,CAAC,IAAI,6BAAM,sBAAqB,CAAA,GAAK,GAAG,GAAG,EAAE;SACnE;QACL,mBAAmB,6BAAM;OAC5B;IACL;IACA,MAAM,OAAO,QAAQ,SAAQ;AACzB,aAAO,2BAA2B;QAC9B,OAAO;QACP,cAAe,MAAM,UAAU,QAAO,MAAQ,WAAW;QACzD,cAAc,CAAC,QACX,UAAU,KAAK,KAAK;UAChB,GAAG;UACH,mBAAmB,CAAC,IAAI,6BAAM,sBAAqB,CAAA,GAAK,GAAG,GAAG,QAAQ;SACzE;QACL,gBAAgB,CAAC,OAAO,QACpB,YAAY,KAAK,OAAO;UACpB,GAAG;UACH,mBAAmB,CAAC,IAAI,6BAAM,sBAAqB,CAAA,GAAK,GAAG,GAAG,EAAE;SACnE;QACL,mBAAmB,6BAAM;OAC5B;IACL;IACA,SAAS,MAAM,WAAW;;AAG9B,SAAO;IACH,GAAG,oBAAoB,UAAU;IACjC,GAAG,eAAe,UAAU;;AAEpC;AAEA,eAAe,2BAAqF,EAChG,OACA,cACA,cACA,gBACA,oBAAoB,CAAA,EAAE,GAOzB;AACG,MAAI,CAAC,cAAc,KAAK,GAAG;AACvB,WAAO;MACH,IAAI;MACJ,QAAQ;QACJ;UACI,MAAM;UACN,SAAS,gCAAgC,OAAO,QAAQ;;;;EAIxE;AAEA,SAAO,QAAQ,KAAK,EAAE,OAClB,OAAO,YAAY,CAAC,WAAWC,MAAK,MAAK;AAErC,QAAIA,UAAS,MAAM;AACf,aAAO;IACX;AAEA,UAAM,MAAM,MAAM;AAElB,QAAI,MAAuB;AAC3B,QAAI,cAAc;AACd,YAAM,YAAY,UAAU,SAAS,IAAI,OAAO,SAAS,IAAI;AAC7D,UAAI,CAAC,MAAM,SAAS,GAAG;AACnB,cAAM;MACV;IACJ;AACA,UAAM,iBAAiB,MAAM,aAAa,GAAG;AAE7C,UAAM,mBAAmB,MAAM,eAAeA,QAAO,GAAG;AAExD,QAAI,IAAI,MAAM,eAAe,MAAM,iBAAiB,IAAI;AACpD,aAAO;QACH,IAAI;QACJ,OAAO;UACH,GAAG,IAAI;UACP,CAAC,eAAe,KAAK,GAAG,iBAAiB;;;IAGrD;AAEA,UAAM,SAA4B,CAAA;AAClC,QAAI,CAAC,IAAI,IAAI;AACT,aAAO,KAAK,GAAG,IAAI,MAAM;IAC7B;AACA,QAAI,CAAC,eAAe,IAAI;AACpB,aAAO,KAAK,GAAG,eAAe,MAAM;IACxC;AACA,QAAI,CAAC,iBAAiB,IAAI;AACtB,aAAO,KAAK,GAAG,iBAAiB,MAAM;IAC1C;AAEA,WAAO;MACH,IAAI;MACJ;;EAER,GACA,QAAQ,QAAQ,EAAE,IAAI,MAAM,OAAO,CAAA,EAA8C,CAAE,CAAC;AAE5F;;;AC5HM,SAAU,IAAiB,QAA2B;AACxD,QAAM,aAAa,KAAK,MAAM;AAC9B,QAAM,aAA6C;IAC/C,OAAO,OAAO,KAAK,SAAQ;AACvB,YAAM,aAAa,MAAM,WAAW,MAAM,KAAK,IAAI;AACnD,UAAI,WAAW,IAAI;AACf,eAAO;UACH,IAAI;UACJ,OAAO,IAAI,IAAI,WAAW,KAAK;;MAEvC,OAAO;AACH,eAAO;MACX;IACJ;IACA,MAAM,OAAO,QAAQ,SAAQ;AACzB,UAAI,EAAE,kBAAkB,MAAM;AAC1B,eAAO;UACH,IAAI;UACJ,QAAQ;YACJ;cACI,OAAM,6BAAM,sBAAqB,CAAA;cACjC,SAAS,gCAAgC,QAAQ,KAAK;;;;MAItE;AACA,YAAM,WAAW,MAAM,WAAW,KAAK,CAAC,GAAG,MAAM,GAAG,IAAI;AACxD,aAAO;IACX;IACA,SAAS,MAAM,WAAW;;AAG9B,SAAO;IACH,GAAG,oBAAoB,UAAU;IACjC,GAAG,eAAe,UAAU;;AAEpC;;;ACpCM,SAAU,qBACZ,SAAgB;AAEhB,QAAM,aAGF;IACA,OAAO,OAAO,KAAK,SAAQ;AACvB,aAAO,yCACH,CAAC,QAAQC,UAAS,OAAO,MAAM,KAAKA,KAAI,GACxC,SACA,IAAI;IAEZ;IACA,MAAM,OAAO,QAAQ,SAAQ;AACzB,aAAO,yCACH,CAAC,QAAQA,UAAS,OAAO,KAAK,QAAQA,KAAI,GAC1C,SACA,IAAI;IAEZ;IACA,SAAS,MAAM,WAAW;;AAG9B,SAAO;IACH,GAAG,oBAAoB,UAAU;IACjC,GAAG,eAAe,UAAU;;AAEpC;AAEA,eAAe,yCACXC,YACA,SACA,MAA+B;AAE/B,QAAM,SAA4B,CAAA;AAClC,aAAW,CAAC,OAAO,MAAM,KAAK,QAAQ,QAAO,GAAI;AAC7C,UAAM,cAAc,MAAMA,WAAU,QAAQ,EAAE,GAAG,MAAM,gBAAgB,MAAK,CAAE;AAC9E,QAAI,YAAY,IAAI;AAChB,aAAO;IACX,OAAO;AACH,iBAAW,SAAS,YAAY,QAAQ;AACpC,eAAO,KAAK;UACR,MAAM,MAAM;UACZ,SAAS,YAAY,KAAK,KAAK,MAAM,OAAO;SAC/C;MACL;IACJ;EACJ;AAEA,SAAO;IACH,IAAI;IACJ;;AAER;;;AC5DM,SAAU,aACZ,oBACA,iBAAgC;AAEhC,SAAO;IACH;IACA;;AAER;;;ACKM,SAAU,MACZC,eACAC,QAAQ;AAER,QAAM,kBACF,OAAOD,kBAAiB,WAAWA,gBAAgBA,cAAa;AACpE,QAAM,qBACF,OAAOA,kBAAiB,WAClBA,gBACCA,cAAa;AAExB,QAAM,0BAA0B,MAAM,KAAKC,MAAK,CAAa;AAE7D,QAAM,aAAsE;IACxE,OAAO,OAAO,KAAK,SAAQ;AACvB,aAAO,0BAA0B;QAC7B,OAAO;QACP,cAAc;QACd,yBAAyB;QACzB,4BAA4B,CAAC,sBACzB,wBAAwB,MAAM,mBAAmB;UAC7C,6BAA6B,6BAAM;UACnC,mBAAmB,CAAC,IAAI,6BAAM,sBAAqB,CAAA,GAAK,eAAe;SAC1E;QACL,+BAA+B,CAAC,sBAAsBA,OAAM,iBAAiB;QAC7E,+BAA+B,6BAAM;QACrC,+BAA+B,CAAC,sBAAsB,+BAClD,2BAA2B,MAAM,sBAAsB,IAAI;QAC/D,mBAAmB,6BAAM;OAC5B;IACL;IACA,MAAM,OAAO,QAAQ,SAAQ;AACzB,aAAO,0BAA0B;QAC7B,OAAO;QACP,cAAc;QACd,yBAAyB;QACzB,4BAA4B,CAAC,sBACzB,wBAAwB,KAAK,mBAAmB;UAC5C,6BAA6B,6BAAM;UACnC,mBAAmB,CAAC,IAAI,6BAAM,sBAAqB,CAAA,GAAK,kBAAkB;SAC7E;QACL,+BAA+B,CAAC,sBAAsBA,OAAM,iBAAiB;QAC7E,+BAA+B,6BAAM;QACrC,+BAA+B,CAAC,sBAAsB,+BAClD,2BAA2B,KAAK,sBAAsB,IAAI;QAC9D,mBAAmB,6BAAM;OAC5B;IACL;IACA,SAAS,MAAM,WAAW;;AAG9B,SAAO;IACH,GAAG,oBAAoB,UAAU;IACjC,GAAG,eAAe,UAAU;IAC5B,GAAG,mBAAmB,UAAU;;AAExC;AAEA,eAAe,0BAIb,EACE,OACA,cAAAD,eACA,yBACA,4BACA,+BACA,gCAAgC,OAChC,+BACA,oBAAoB,CAAA,EAAE,GAazB;AAGG,MAAI,CAAC,cAAc,KAAK,GAAG;AACvB,WAAO;MACH,IAAI;MACJ,QAAQ;QACJ;UACI,MAAM;UACN,SAAS,gCAAgC,OAAO,QAAQ;;;;EAIxE;AAEA,QAAM,EAAE,CAACA,aAAY,GAAG,mBAAmB,GAAG,qBAAoB,IAAK;AAEvE,MAAI,qBAAqB,MAAM;AAC3B,WAAO;MACH,IAAI;MACJ,QAAQ;QACJ;UACI,MAAM;UACN,SAAS,0BAA0BA,aAAY;;;;EAI/D;AAEA,QAAM,+BAA+B,MAAM,2BAA2B,iBAAiB;AACvF,MAAI,CAAC,6BAA6B,IAAI;AAClC,WAAO;MACH,IAAI;MACJ,QAAQ,6BAA6B;;EAE7C;AAEA,QAAM,6BAA6B,8BAA8B,6BAA6B,KAAK;AAEnG,MAAI,8BAA8B,MAAM;AACpC,QAAI,+BAA+B;AAC/B,aAAO;QACH,IAAI;QACJ,OAAO;UACH,CAAC,uBAAuB,GAAG,6BAA6B;UACxD,GAAG;;;IAGf,OAAO;AACH,aAAO;QACH,IAAI;QACJ,QAAQ;UACJ;YACI,MAAM,CAAC,GAAG,mBAAmBA,aAAY;YACzC,SAAS;;;;IAIzB;EACJ;AAEA,QAAM,kCAAkC,MAAM,8BAC1C,sBACA,0BAA0B;AAE9B,MAAI,CAAC,gCAAgC,IAAI;AACrC,WAAO;EACX;AAEA,SAAO;IACH,IAAI;IACJ,OAAO;MACH,CAAC,uBAAuB,GAAG;MAC3B,GAAG,gCAAgC;;;AAG/C;",
  "names": ["transform", "date", "object", "object", "property", "value", "value", "opts", "transform", "discriminant", "union"]
}
