import {
  require_side_channel
} from "./chunk-SOYXYHEY.js";
import {
  Blob,
  File
} from "./chunk-5I6D3TFU.js";
import {
  schemas_exports
} from "./chunk-NR75SPB4.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-UN725CXD.js";

// node_modules/@fileforge/client/node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/@fileforge/client/node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/@fileforge/client/node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@fileforge/client/node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/@fileforge/client/node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/@fileforge/client/node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/@fileforge/client/node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/@fileforge/client/node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/@fileforge/client/node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/@fileforge/client/node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// node_modules/url-join/lib/url-join.js
var require_url_join = __commonJS({
  "node_modules/url-join/lib/url-join.js"(exports, module) {
    (function(name, context, definition) {
      if (typeof module !== "undefined" && module.exports) module.exports = definition();
      else if (typeof define === "function" && define.amd) define(definition);
      else context[name] = definition();
    })("urljoin", exports, function() {
      function normalize(strArray) {
        var resultArray = [];
        if (strArray.length === 0) {
          return "";
        }
        if (typeof strArray[0] !== "string") {
          throw new TypeError("Url must be a string. Received " + strArray[0]);
        }
        if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
          var first = strArray.shift();
          strArray[0] = first + strArray[0];
        }
        if (strArray[0].match(/^file:\/\/\//)) {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1:///");
        } else {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1://");
        }
        for (var i = 0; i < strArray.length; i++) {
          var component = strArray[i];
          if (typeof component !== "string") {
            throw new TypeError("Url must be a string. Received " + component);
          }
          if (component === "") {
            continue;
          }
          if (i > 0) {
            component = component.replace(/^[\/]+/, "");
          }
          if (i < strArray.length - 1) {
            component = component.replace(/[\/]+$/, "");
          } else {
            component = component.replace(/[\/]+$/, "/");
          }
          resultArray.push(component);
        }
        var str = resultArray.join("/");
        str = str.replace(/\/(\?|&|#[^!])/g, "$1");
        var parts = str.split("?");
        str = parts.shift() + (parts.length > 0 ? "?" : "") + parts.join("&");
        return str;
      }
      return function() {
        var input;
        if (typeof arguments[0] === "object") {
          input = arguments[0];
        } else {
          input = [].slice.call(arguments);
        }
        return normalize(input);
      };
    });
  }
});

// node_modules/@fileforge/client/dist/esm/client/codegen/api/index.js
var api_exports = {};
__export(api_exports, {
  BadGatewayError: () => BadGatewayError,
  BadRequestError: () => BadRequestError,
  InternalServerError: () => InternalServerError,
  UnauthorizedError: () => UnauthorizedError,
  pdf: () => pdf_exports
});

// node_modules/@fileforge/client/dist/esm/client/codegen/api/resources/pdf/index.js
var pdf_exports = {};
__export(pdf_exports, {
  FormDetectResponseItemIsEditableType: () => FormDetectResponseItemIsEditableType,
  FormFillRequestOptionsFieldsItemTwoType: () => FormFillRequestOptionsFieldsItemTwoType,
  form: () => form_exports
});

// node_modules/@fileforge/client/dist/esm/client/codegen/api/resources/pdf/resources/form/index.js
var form_exports = {};
__export(form_exports, {
  FormDetectResponseItemIsEditableType: () => FormDetectResponseItemIsEditableType,
  FormFillRequestOptionsFieldsItemTwoType: () => FormFillRequestOptionsFieldsItemTwoType
});

// node_modules/@fileforge/client/dist/esm/client/codegen/api/resources/pdf/resources/form/types/FormDetectResponseItemIsEditableType.js
var FormDetectResponseItemIsEditableType = {
  PdfDropdown: "PDFDropdown",
  PdfOptionList: "PDFOptionList"
};

// node_modules/@fileforge/client/dist/esm/client/codegen/api/resources/pdf/resources/form/types/FormFillRequestOptionsFieldsItemTwoType.js
var FormFillRequestOptionsFieldsItemTwoType = {
  PdfOptionList: "PDFOptionList",
  PdfDropdown: "PDFDropdown"
};

// node_modules/@fileforge/client/dist/esm/client/codegen/errors/FileforgeError.js
var FileforgeError = class _FileforgeError extends Error {
  constructor({ message, statusCode, body }) {
    super(buildMessage({ message, statusCode, body }));
    __publicField(this, "statusCode");
    __publicField(this, "body");
    Object.setPrototypeOf(this, _FileforgeError.prototype);
    if (statusCode != null) {
      this.statusCode = statusCode;
    }
    if (body !== void 0) {
      this.body = body;
    }
  }
};
function buildMessage({ message, statusCode, body }) {
  let lines = [];
  if (message != null) {
    lines.push(message);
  }
  if (statusCode != null) {
    lines.push(`Status code: ${statusCode.toString()}`);
  }
  if (body != null) {
    lines.push(`Body: ${JSON.stringify(body, void 0, 2)}`);
  }
  return lines.join("\n");
}

// node_modules/@fileforge/client/dist/esm/client/codegen/errors/FileforgeTimeoutError.js
var FileforgeTimeoutError = class _FileforgeTimeoutError extends Error {
  constructor() {
    super("Timeout");
    Object.setPrototypeOf(this, _FileforgeTimeoutError.prototype);
  }
};

// node_modules/@fileforge/client/dist/esm/client/codegen/api/errors/BadRequestError.js
var BadRequestError = class _BadRequestError extends FileforgeError {
  constructor(body) {
    super({
      message: "BadRequestError",
      statusCode: 400,
      body
    });
    Object.setPrototypeOf(this, _BadRequestError.prototype);
  }
};

// node_modules/@fileforge/client/dist/esm/client/codegen/api/errors/UnauthorizedError.js
var UnauthorizedError = class _UnauthorizedError extends FileforgeError {
  constructor(body) {
    super({
      message: "UnauthorizedError",
      statusCode: 401,
      body
    });
    Object.setPrototypeOf(this, _UnauthorizedError.prototype);
  }
};

// node_modules/@fileforge/client/dist/esm/client/codegen/api/errors/InternalServerError.js
var InternalServerError = class _InternalServerError extends FileforgeError {
  constructor(body) {
    super({
      message: "InternalServerError",
      statusCode: 500,
      body
    });
    Object.setPrototypeOf(this, _InternalServerError.prototype);
  }
};

// node_modules/@fileforge/client/dist/esm/client/codegen/api/errors/BadGatewayError.js
var BadGatewayError = class _BadGatewayError extends FileforgeError {
  constructor(body) {
    super({
      message: "BadGatewayError",
      statusCode: 502,
      body
    });
    Object.setPrototypeOf(this, _BadGatewayError.prototype);
  }
};

// node_modules/@fileforge/client/dist/esm/client/codegen/environments.js
var FileforgeEnvironment = {
  Default: "https://api.fileforge.com"
};

// node_modules/@fileforge/client/dist/esm/client/codegen/core/fetcher/Fetcher.js
var import_qs = __toESM(require_lib());

// node_modules/@fileforge/client/dist/esm/client/codegen/core/runtime/runtime.js
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var _a, _b, _c;
var isWebWorker = typeof self === "object" && // @ts-ignore
typeof (self == null ? void 0 : self.importScripts) === "function" && (((_a = self.constructor) == null ? void 0 : _a.name) === "DedicatedWorkerGlobalScope" || ((_b = self.constructor) == null ? void 0 : _b.name) === "ServiceWorkerGlobalScope" || ((_c = self.constructor) == null ? void 0 : _c.name) === "SharedWorkerGlobalScope");
var isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
var isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
var _a2;
var isNode = typeof process !== "undefined" && Boolean(process.version) && Boolean((_a2 = process.versions) == null ? void 0 : _a2.node) && // Deno spoofs process.versions.node, see https://deno.land/std@0.177.0/node/process.ts?s=versions
!isDeno && !isBun;
var isReactNative = typeof navigator !== "undefined" && (navigator == null ? void 0 : navigator.product) === "ReactNative";
var RUNTIME = evaluateRuntime();
function evaluateRuntime() {
  if (isBrowser) {
    return {
      type: "browser",
      version: window.navigator.userAgent
    };
  }
  if (isWebWorker) {
    return {
      type: "web-worker"
    };
  }
  if (isDeno) {
    return {
      type: "deno",
      version: Deno.version.deno
    };
  }
  if (isBun) {
    return {
      type: "bun",
      version: Bun.version
    };
  }
  if (isNode) {
    return {
      type: "node",
      version: process.versions.node
    };
  }
  if (isReactNative) {
    return {
      type: "react-native"
    };
  }
  return {
    type: "unknown"
  };
}

// node_modules/@fileforge/client/dist/esm/client/codegen/core/fetcher/Fetcher.js
var INITIAL_RETRY_DELAY = 1;
var MAX_RETRY_DELAY = 60;
var DEFAULT_MAX_RETRIES = 2;
async function fetcherImpl(args) {
  const headers = {};
  if (args.body !== void 0 && args.contentType != null) {
    headers["Content-Type"] = args.contentType;
  }
  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }
  const url = Object.keys(args.queryParameters ?? {}).length > 0 ? `${args.url}?${import_qs.default.stringify(args.queryParameters, { arrayFormat: "repeat" })}` : args.url;
  let body = void 0;
  const maybeStringifyBody = (body2) => {
    if (body2 instanceof Uint8Array) {
      return body2;
    } else {
      return JSON.stringify(body2);
    }
  };
  if (args.body instanceof (await import("./browser-TYGEDASS.js")).FormData) {
    body = args.body;
  } else {
    try {
      const Readable = (await import("./stream-X7BEF2YV.js")).Readable;
      if (args.body instanceof Readable) {
        body = args.body;
      } else {
        body = maybeStringifyBody(args.body);
      }
    } catch (e) {
      body = maybeStringifyBody(args.body);
    }
  }
  const fetchFn = RUNTIME.type === "node" ? (
    // `.default` is required due to this issue:
    // https://github.com/node-fetch/node-fetch/issues/450#issuecomment-387045223
    (await import("./src-NLAFUYNN.js")).default
  ) : typeof fetch == "function" ? fetch : (await import("./src-NLAFUYNN.js")).default;
  const makeRequest = async () => {
    const signals = [];
    let timeoutAbortId = void 0;
    if (args.timeoutMs != null) {
      const { signal, abortId } = getTimeoutSignal(args.timeoutMs);
      timeoutAbortId = abortId;
      signals.push(signal);
    }
    if (args.abortSignal != null) {
      signals.push(args.abortSignal);
    }
    const response = await fetchFn(url, {
      method: args.method,
      headers,
      body,
      signal: anySignal(signals),
      credentials: args.withCredentials ? "include" : void 0
    });
    if (timeoutAbortId != null) {
      clearTimeout(timeoutAbortId);
    }
    return response;
  };
  try {
    let response = await makeRequest();
    for (let i = 0; i < (args.maxRetries ?? DEFAULT_MAX_RETRIES); ++i) {
      if (response.status === 408 || response.status === 409 || response.status === 429 || response.status >= 500) {
        const delay = Math.min(INITIAL_RETRY_DELAY * Math.pow(i, 2), MAX_RETRY_DELAY);
        await new Promise((resolve) => setTimeout(resolve, delay));
        response = await makeRequest();
      } else {
        break;
      }
    }
    let body2;
    if (response.body != null && args.responseType === "blob") {
      body2 = await response.blob();
    } else if (response.body != null && args.responseType === "streaming") {
      body2 = response.body;
    } else if (response.body != null && args.responseType === "text") {
      body2 = await response.text();
    } else {
      const text = await response.text();
      if (text.length > 0) {
        try {
          body2 = JSON.parse(text);
        } catch (err) {
          return {
            ok: false,
            error: {
              reason: "non-json",
              statusCode: response.status,
              rawBody: text
            }
          };
        }
      }
    }
    if (response.status >= 200 && response.status < 400) {
      return {
        ok: true,
        body: body2,
        headers: response.headers
      };
    } else {
      return {
        ok: false,
        error: {
          reason: "status-code",
          statusCode: response.status,
          body: await response.json()
        }
      };
    }
  } catch (error) {
    if (args.abortSignal != null && args.abortSignal.aborted) {
      return {
        ok: false,
        error: {
          reason: "unknown",
          errorMessage: "The user aborted a request"
        }
      };
    } else if (error instanceof Error && error.name === "AbortError") {
      return {
        ok: false,
        error: {
          reason: "timeout"
        }
      };
    } else if (error instanceof Error) {
      return {
        ok: false,
        error: {
          reason: "unknown",
          errorMessage: error.message
        }
      };
    }
    return {
      ok: false,
      error: {
        reason: "unknown",
        errorMessage: JSON.stringify(error)
      }
    };
  }
}
var TIMEOUT = "timeout";
function getTimeoutSignal(timeoutMs) {
  const controller = new AbortController();
  const abortId = setTimeout(() => controller.abort(TIMEOUT), timeoutMs);
  return { signal: controller.signal, abortId };
}
function anySignal(...args) {
  const signals = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
  const controller = new AbortController();
  for (const signal of signals) {
    if (signal.aborted) {
      controller.abort(signal == null ? void 0 : signal.reason);
      break;
    }
    signal.addEventListener("abort", () => controller.abort(signal == null ? void 0 : signal.reason), {
      signal: controller.signal
    });
  }
  return controller.signal;
}
var fetcher = fetcherImpl;

// node_modules/@fileforge/client/dist/esm/client/codegen/core/fetcher/Supplier.js
var Supplier = {
  get: async (supplier) => {
    if (typeof supplier === "function") {
      return supplier();
    } else {
      return supplier;
    }
  }
};

// node_modules/@fileforge/client/dist/esm/client/codegen/core/form-data-utils/FormDataWrapper.js
var FormDataRequestBody = class {
  constructor(fd) {
    __publicField(this, "fd");
    __publicField(this, "encoder");
    this.fd = fd;
  }
  async setup() {
    if (this.encoder == null && RUNTIME.type === "node") {
      this.encoder = new (await import("./lib-OF32PUS5.js")).FormDataEncoder(this.fd);
    }
  }
  async needsEncoder() {
    if (RUNTIME.type !== "node") {
      return false;
    }
    try {
      return (await import("./node_stream-TRS4EP5H.js")).Readable !== void 0;
    } catch (e) {
      return false;
    }
  }
  /**
   * @returns the multipart form data request
   */
  async getBody() {
    if (!await this.needsEncoder()) {
      return this.fd;
    } else {
      if (this.encoder == null) {
        await this.setup();
      }
      return (await import("./node_stream-TRS4EP5H.js")).Readable.from(this.encoder);
    }
  }
  /**
   * @returns headers that need to be added to the multipart form data request
   */
  async getHeaders() {
    if (!await this.needsEncoder()) {
      return {};
    } else {
      if (this.encoder == null) {
        await this.setup();
      }
      return {
        ...this.encoder.headers,
        "Content-Length": this.encoder.length
      };
    }
  }
};
var FormDataWrapper = class {
  constructor() {
    __publicField(this, "fd");
  }
  async append(name, value) {
    if (this.fd == null) {
      this.fd = new (await import("./browser-TYGEDASS.js")).FormData();
    }
    if (name === "options" && typeof value === "string") {
      this.fd.append("options", new Blob([value], { type: "application/json" }));
      return;
    }
    try {
      const Readable = (await import("./stream-X7BEF2YV.js")).Readable;
      if (RUNTIME.type === "node" && value instanceof Readable) {
        const { stream, mime } = await (await import("./dist-Y5W7VARL.js")).getMimeType(value);
        let fileName = ((Math.random() + 1).toString(36) + "00000000000000000").slice(2, 7);
        this.fd.append(name, {
          type: mime,
          name: fileName,
          [Symbol.toStringTag]: "File",
          stream() {
            return stream;
          }
        });
        return;
      }
    } catch (e) {
    }
    this.fd.append(name, value);
  }
  getRequest() {
    return new FormDataRequestBody(this.fd);
  }
};

// node_modules/@fileforge/client/dist/esm/client/codegen/Client.js
var import_url_join3 = __toESM(require_url_join());

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/index.js
var pdf_exports2 = {};
__export(pdf_exports2, {
  FormDetectRequestOptions: () => FormDetectRequestOptions,
  FormDetectResponseItem: () => FormDetectResponseItem,
  FormDetectResponseItemIsChecked: () => FormDetectResponseItemIsChecked,
  FormDetectResponseItemIsCombed: () => FormDetectResponseItemIsCombed,
  FormDetectResponseItemIsEditable: () => FormDetectResponseItemIsEditable,
  FormDetectResponseItemIsEditableType: () => FormDetectResponseItemIsEditableType2,
  FormDetectResponseItemIsMutuallyExclusive: () => FormDetectResponseItemIsMutuallyExclusive,
  FormDetectResponseItemType: () => FormDetectResponseItemType,
  FormFillRequestOptions: () => FormFillRequestOptions,
  FormFillRequestOptionsFieldsItem: () => FormFillRequestOptionsFieldsItem,
  FormFillRequestOptionsFieldsItemChecked: () => FormFillRequestOptionsFieldsItemChecked,
  FormFillRequestOptionsFieldsItemThree: () => FormFillRequestOptionsFieldsItemThree,
  FormFillRequestOptionsFieldsItemTwo: () => FormFillRequestOptionsFieldsItemTwo,
  FormFillRequestOptionsFieldsItemTwoType: () => FormFillRequestOptionsFieldsItemTwoType2,
  FormFillRequestOptionsFieldsItemValue: () => FormFillRequestOptionsFieldsItemValue,
  FormMarkRequestOptions: () => FormMarkRequestOptions,
  PdfExtractRequestOptions: () => PdfExtractRequestOptions,
  PdfFromDocxRequestOptions: () => PdfFromDocxRequestOptions,
  PdfGenerateRequestOptions: () => PdfGenerateRequestOptions,
  PdfInsertRequestOptions: () => PdfInsertRequestOptions,
  PdfMergeRequestOptions: () => PdfMergeRequestOptions,
  PdfSplitRequestOptions: () => PdfSplitRequestOptions,
  form: () => form_exports2
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/types/PdfFromDocxRequestOptions.js
var PdfFromDocxRequestOptions = schemas_exports.object({
  keepOriginalStyles: schemas_exports.boolean().optional(),
  templateLiterals: schemas_exports.record(schemas_exports.string(), schemas_exports.string()).optional()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/types/PdfGenerateRequestOptions.js
var PdfGenerateRequestOptions = schemas_exports.object({
  test: schemas_exports.boolean().optional(),
  host: schemas_exports.boolean().optional(),
  expiresAt: schemas_exports.date().optional(),
  fileName: schemas_exports.string().optional()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/types/PdfMergeRequestOptions.js
var PdfMergeRequestOptions = schemas_exports.object({});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/types/PdfSplitRequestOptions.js
var PdfSplitRequestOptions = schemas_exports.object({
  splitPage: schemas_exports.number()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/types/PdfExtractRequestOptions.js
var PdfExtractRequestOptions = schemas_exports.object({
  start: schemas_exports.number(),
  end: schemas_exports.number()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/types/PdfInsertRequestOptions.js
var PdfInsertRequestOptions = schemas_exports.object({
  insertPage: schemas_exports.number()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/index.js
var form_exports2 = {};
__export(form_exports2, {
  FormDetectRequestOptions: () => FormDetectRequestOptions,
  FormDetectResponseItem: () => FormDetectResponseItem,
  FormDetectResponseItemIsChecked: () => FormDetectResponseItemIsChecked,
  FormDetectResponseItemIsCombed: () => FormDetectResponseItemIsCombed,
  FormDetectResponseItemIsEditable: () => FormDetectResponseItemIsEditable,
  FormDetectResponseItemIsEditableType: () => FormDetectResponseItemIsEditableType2,
  FormDetectResponseItemIsMutuallyExclusive: () => FormDetectResponseItemIsMutuallyExclusive,
  FormDetectResponseItemType: () => FormDetectResponseItemType,
  FormFillRequestOptions: () => FormFillRequestOptions,
  FormFillRequestOptionsFieldsItem: () => FormFillRequestOptionsFieldsItem,
  FormFillRequestOptionsFieldsItemChecked: () => FormFillRequestOptionsFieldsItemChecked,
  FormFillRequestOptionsFieldsItemThree: () => FormFillRequestOptionsFieldsItemThree,
  FormFillRequestOptionsFieldsItemTwo: () => FormFillRequestOptionsFieldsItemTwo,
  FormFillRequestOptionsFieldsItemTwoType: () => FormFillRequestOptionsFieldsItemTwoType2,
  FormFillRequestOptionsFieldsItemValue: () => FormFillRequestOptionsFieldsItemValue,
  FormMarkRequestOptions: () => FormMarkRequestOptions,
  detect: () => detect_exports
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormDetectRequestOptions.js
var FormDetectRequestOptions = schemas_exports.object({});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormDetectResponseItemIsChecked.js
var FormDetectResponseItemIsChecked = schemas_exports.object({
  type: schemas_exports.stringLiteral("PDFCheckBox"),
  isChecked: schemas_exports.boolean().optional()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormDetectResponseItemIsEditableType.js
var FormDetectResponseItemIsEditableType2 = schemas_exports.enum_(["PDFDropdown", "PDFOptionList"]);

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormDetectResponseItemIsEditable.js
var FormDetectResponseItemIsEditable = schemas_exports.object({
  type: FormDetectResponseItemIsEditableType2,
  options: schemas_exports.list(schemas_exports.string()).optional(),
  isMultiselect: schemas_exports.boolean().optional(),
  selected: schemas_exports.list(schemas_exports.string()).optional(),
  isEditable: schemas_exports.boolean().optional()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormDetectResponseItemIsMutuallyExclusive.js
var FormDetectResponseItemIsMutuallyExclusive = schemas_exports.object({
  type: schemas_exports.stringLiteral("PDFRadioGroup"),
  options: schemas_exports.list(schemas_exports.string()).optional(),
  selected: schemas_exports.string().optional(),
  isMutuallyExclusive: schemas_exports.boolean().optional(),
  isOffToggleable: schemas_exports.boolean().optional()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormDetectResponseItemIsCombed.js
var FormDetectResponseItemIsCombed = schemas_exports.object({
  type: schemas_exports.stringLiteral("PDFTextField"),
  defaultValue: schemas_exports.string().optional(),
  isPassword: schemas_exports.boolean().optional(),
  isRichFormatted: schemas_exports.boolean().optional(),
  isScrollable: schemas_exports.boolean().optional(),
  isCombed: schemas_exports.boolean().optional(),
  isMultiline: schemas_exports.boolean().optional(),
  isFileSelector: schemas_exports.boolean().optional(),
  maxLength: schemas_exports.number().optional()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormDetectResponseItemType.js
var FormDetectResponseItemType = schemas_exports.object({
  type: schemas_exports.stringLiteral("PDFSignature"),
  defaultValue: schemas_exports.string().optional()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormDetectResponseItem.js
var FormDetectResponseItem = schemas_exports.undiscriminatedUnion([
  FormDetectResponseItemIsChecked,
  FormDetectResponseItemIsEditable,
  FormDetectResponseItemIsMutuallyExclusive,
  FormDetectResponseItemIsCombed,
  FormDetectResponseItemType
]);

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormMarkRequestOptions.js
var FormMarkRequestOptions = schemas_exports.object({});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormFillRequestOptionsFieldsItemValue.js
var FormFillRequestOptionsFieldsItemValue = schemas_exports.object({
  name: schemas_exports.string(),
  type: schemas_exports.stringLiteral("PDFTextField"),
  value: schemas_exports.string()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormFillRequestOptionsFieldsItemChecked.js
var FormFillRequestOptionsFieldsItemChecked = schemas_exports.object({
  name: schemas_exports.string(),
  type: schemas_exports.stringLiteral("PDFCheckBox"),
  checked: schemas_exports.boolean()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormFillRequestOptionsFieldsItemTwoType.js
var FormFillRequestOptionsFieldsItemTwoType2 = schemas_exports.enum_(["PDFOptionList", "PDFDropdown"]);

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormFillRequestOptionsFieldsItemTwo.js
var FormFillRequestOptionsFieldsItemTwo = schemas_exports.object({
  name: schemas_exports.string(),
  type: FormFillRequestOptionsFieldsItemTwoType2,
  selected: schemas_exports.list(schemas_exports.string())
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormFillRequestOptionsFieldsItemThree.js
var FormFillRequestOptionsFieldsItemThree = schemas_exports.object({
  name: schemas_exports.string(),
  type: schemas_exports.stringLiteral("PDFRadioGroup"),
  selected: schemas_exports.string()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormFillRequestOptionsFieldsItem.js
var FormFillRequestOptionsFieldsItem = schemas_exports.undiscriminatedUnion([
  FormFillRequestOptionsFieldsItemValue,
  FormFillRequestOptionsFieldsItemChecked,
  FormFillRequestOptionsFieldsItemTwo,
  FormFillRequestOptionsFieldsItemThree
]);

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/types/FormFillRequestOptions.js
var FormFillRequestOptions = schemas_exports.object({
  fields: schemas_exports.list(FormFillRequestOptionsFieldsItem)
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/resources/pdf/resources/form/client/detect.js
var detect_exports = {};
__export(detect_exports, {
  Response: () => Response2
});
var Response2 = schemas_exports.list(FormDetectResponseItem);

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/types/GetStatusResponse.js
var GetStatusResponse = schemas_exports.object({
  status: schemas_exports.string().optional()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/serialization/types/ErrorSchema.js
var ErrorSchema = schemas_exports.object({
  statusCode: schemas_exports.number(),
  code: schemas_exports.string(),
  message: schemas_exports.string()
});

// node_modules/@fileforge/client/dist/esm/client/codegen/api/resources/pdf/client/Client.js
var import_url_join2 = __toESM(require_url_join());

// node_modules/@fileforge/client/dist/esm/client/codegen/api/resources/pdf/resources/form/client/Client.js
var import_url_join = __toESM(require_url_join());
var Form = class {
  constructor(_options = {}) {
    __publicField(this, "_options");
    this._options = _options;
  }
  /**
   * Returns a list of form fields detected in the PDF document, along with their location, options and requirements. For a more visual representation, use the /pdf/form/mark endpoint.
   *
   * @param {File | fs.ReadStream} file
   * @param {Fileforge.pdf.FormDetectRequest} request
   * @param {Form.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Fileforge.BadRequestError}
   * @throws {@link Fileforge.UnauthorizedError}
   * @throws {@link Fileforge.InternalServerError}
   *
   * @example
   *     await fileforge.pdf.form.detect(fs.createReadStream("/path/to/your/file"), {})
   */
  async detect(file, request, requestOptions) {
    const _request = new FormDataWrapper();
    if (request.options != null) {
      await _request.append("options", JSON.stringify(request.options));
    }
    await _request.append("file", file);
    const _maybeEncodedRequest = _request.getRequest();
    const _response = await fetcher({
      url: (0, import_url_join.default)(await Supplier.get(this._options.environment) ?? FileforgeEnvironment.Default, "pdf/form/detect/"),
      method: "POST",
      headers: {
        "X-Fern-Language": "JavaScript",
        "X-Fern-Runtime": RUNTIME.type,
        "X-Fern-Runtime-Version": RUNTIME.version,
        ...await this._getCustomAuthorizationHeaders(),
        ...await _maybeEncodedRequest.getHeaders()
      },
      body: await _maybeEncodedRequest.getBody(),
      timeoutMs: (requestOptions == null ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
      maxRetries: requestOptions == null ? void 0 : requestOptions.maxRetries,
      abortSignal: requestOptions == null ? void 0 : requestOptions.abortSignal
    });
    if (_response.ok) {
      return await pdf_exports2.form.detect.Response.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true,
        breadcrumbsPrefix: ["response"]
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new BadRequestError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 401:
          throw new UnauthorizedError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 500:
          throw new InternalServerError(_response.error.body);
        default:
          throw new FileforgeError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new FileforgeError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new FileforgeTimeoutError();
      case "unknown":
        throw new FileforgeError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Returns a modified PDF document with form fields marked with a green border, and hover text showing the field name.
   * @throws {@link Fileforge.BadRequestError}
   * @throws {@link Fileforge.UnauthorizedError}
   * @throws {@link Fileforge.InternalServerError}
   */
  async mark(file, request, requestOptions) {
    const _request = new FormDataWrapper();
    if (request.options != null) {
      await _request.append("options", JSON.stringify(request.options));
    }
    await _request.append("file", file);
    const _maybeEncodedRequest = _request.getRequest();
    const _response = await fetcher({
      url: (0, import_url_join.default)(await Supplier.get(this._options.environment) ?? FileforgeEnvironment.Default, "pdf/form/mark/"),
      method: "POST",
      headers: {
        "X-Fern-Language": "JavaScript",
        "X-Fern-Runtime": RUNTIME.type,
        "X-Fern-Runtime-Version": RUNTIME.version,
        ...await this._getCustomAuthorizationHeaders(),
        ...await _maybeEncodedRequest.getHeaders()
      },
      body: await _maybeEncodedRequest.getBody(),
      responseType: "streaming",
      timeoutMs: (requestOptions == null ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
      maxRetries: requestOptions == null ? void 0 : requestOptions.maxRetries,
      abortSignal: requestOptions == null ? void 0 : requestOptions.abortSignal
    });
    if (_response.ok) {
      return _response.body;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new BadRequestError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 401:
          throw new UnauthorizedError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 500:
          throw new InternalServerError(_response.error.body);
        default:
          throw new FileforgeError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new FileforgeError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new FileforgeTimeoutError();
      case "unknown":
        throw new FileforgeError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Returns a modified PDF document with filled form fields. A subset of fields can be filled.
   * @throws {@link Fileforge.BadRequestError}
   * @throws {@link Fileforge.UnauthorizedError}
   * @throws {@link Fileforge.InternalServerError}
   */
  async fill(file, request, requestOptions) {
    const _request = new FormDataWrapper();
    if (request.options != null) {
      await _request.append("options", JSON.stringify(request.options));
    }
    await _request.append("file", file);
    const _maybeEncodedRequest = _request.getRequest();
    const _response = await fetcher({
      url: (0, import_url_join.default)(await Supplier.get(this._options.environment) ?? FileforgeEnvironment.Default, "pdf/form/fill/"),
      method: "POST",
      headers: {
        "X-Fern-Language": "JavaScript",
        "X-Fern-Runtime": RUNTIME.type,
        "X-Fern-Runtime-Version": RUNTIME.version,
        ...await this._getCustomAuthorizationHeaders(),
        ...await _maybeEncodedRequest.getHeaders()
      },
      body: await _maybeEncodedRequest.getBody(),
      responseType: "streaming",
      timeoutMs: (requestOptions == null ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
      maxRetries: requestOptions == null ? void 0 : requestOptions.maxRetries,
      abortSignal: requestOptions == null ? void 0 : requestOptions.abortSignal
    });
    if (_response.ok) {
      return _response.body;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new BadRequestError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 401:
          throw new UnauthorizedError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 500:
          throw new InternalServerError(_response.error.body);
        default:
          throw new FileforgeError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new FileforgeError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new FileforgeTimeoutError();
      case "unknown":
        throw new FileforgeError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getCustomAuthorizationHeaders() {
    const apiKeyValue = await Supplier.get(this._options.apiKey);
    return { "X-API-Key": apiKeyValue };
  }
};

// node_modules/@fileforge/client/dist/esm/client/codegen/api/resources/pdf/client/Client.js
var Pdf = class {
  constructor(_options = {}) {
    __publicField(this, "_options");
    __publicField(this, "_form");
    this._options = _options;
  }
  /**
   * Converts a Microsoft Word document (.DOCX or .DOC) file to a PDF document.
   *
   * This service uses a LibreOffice headless server to perform the conversion, and may not support all features of the original document.
   *
   * **Known discrepancies**
   *
   * - Some fonts may not be available in the server, and may be substituted by a closest match.
   * - Some complex formatting may not be preserved, such as background graphics.
   *
   * **Variables**
   *
   * Variable replacement is supported with various methods:
   *
   * - Templated litterals: `{{name}}`
   * - Word variables, as listed in the document metadata: `{DOCVARIABLE "name"}`
   *
   * To enable variable replacement as Word variables for your account, please contact the FileForge support.
   * @throws {@link Fileforge.BadRequestError}
   * @throws {@link Fileforge.UnauthorizedError}
   * @throws {@link Fileforge.InternalServerError}
   */
  async fromDocx(file, request, requestOptions) {
    const _request = new FormDataWrapper();
    if (request.options != null) {
      await _request.append("options", JSON.stringify(request.options));
    }
    await _request.append("file", file);
    const _maybeEncodedRequest = _request.getRequest();
    const _response = await fetcher({
      url: (0, import_url_join2.default)(await Supplier.get(this._options.environment) ?? FileforgeEnvironment.Default, "pdf/docx/"),
      method: "POST",
      headers: {
        "X-Fern-Language": "JavaScript",
        "X-Fern-Runtime": RUNTIME.type,
        "X-Fern-Runtime-Version": RUNTIME.version,
        ...await this._getCustomAuthorizationHeaders(),
        ...await _maybeEncodedRequest.getHeaders()
      },
      body: await _maybeEncodedRequest.getBody(),
      responseType: "streaming",
      timeoutMs: (requestOptions == null ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
      maxRetries: requestOptions == null ? void 0 : requestOptions.maxRetries,
      abortSignal: requestOptions == null ? void 0 : requestOptions.abortSignal
    });
    if (_response.ok) {
      return _response.body;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new BadRequestError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 401:
          throw new UnauthorizedError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 500:
          throw new InternalServerError(_response.error.body);
        default:
          throw new FileforgeError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new FileforgeError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new FileforgeTimeoutError();
      case "unknown":
        throw new FileforgeError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Generates a PDF document from web assets.
   * @throws {@link Fileforge.BadRequestError}
   * @throws {@link Fileforge.UnauthorizedError}
   * @throws {@link Fileforge.InternalServerError}
   * @throws {@link Fileforge.BadGatewayError}
   */
  async generate(files, request, requestOptions) {
    const _request = new FormDataWrapper();
    if (request.options != null) {
      await _request.append("options", JSON.stringify(request.options));
    }
    for (const _file of files) {
      await _request.append("files", _file);
    }
    const _maybeEncodedRequest = _request.getRequest();
    const _response = await fetcher({
      url: (0, import_url_join2.default)(await Supplier.get(this._options.environment) ?? FileforgeEnvironment.Default, "pdf/generate/"),
      method: "POST",
      headers: {
        "X-Fern-Language": "JavaScript",
        "X-Fern-Runtime": RUNTIME.type,
        "X-Fern-Runtime-Version": RUNTIME.version,
        ...await this._getCustomAuthorizationHeaders(),
        ...await _maybeEncodedRequest.getHeaders()
      },
      body: await _maybeEncodedRequest.getBody(),
      responseType: "streaming",
      timeoutMs: (requestOptions == null ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
      maxRetries: requestOptions == null ? void 0 : requestOptions.maxRetries,
      abortSignal: requestOptions == null ? void 0 : requestOptions.abortSignal
    });
    if (_response.ok) {
      return _response.body;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new BadRequestError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 401:
          throw new UnauthorizedError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 500:
          throw new InternalServerError(_response.error.body);
        case 502:
          throw new BadGatewayError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        default:
          throw new FileforgeError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new FileforgeError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new FileforgeTimeoutError();
      case "unknown":
        throw new FileforgeError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Merges multiple PDF documents into a single PDF document.
   * @throws {@link Fileforge.BadRequestError}
   * @throws {@link Fileforge.UnauthorizedError}
   * @throws {@link Fileforge.InternalServerError}
   */
  async merge(files, request, requestOptions) {
    const _request = new FormDataWrapper();
    if (request.options != null) {
      await _request.append("options", JSON.stringify(request.options));
    }
    for (const _file of files) {
      await _request.append("files", _file);
    }
    const _maybeEncodedRequest = _request.getRequest();
    const _response = await fetcher({
      url: (0, import_url_join2.default)(await Supplier.get(this._options.environment) ?? FileforgeEnvironment.Default, "pdf/merge/"),
      method: "POST",
      headers: {
        "X-Fern-Language": "JavaScript",
        "X-Fern-Runtime": RUNTIME.type,
        "X-Fern-Runtime-Version": RUNTIME.version,
        ...await this._getCustomAuthorizationHeaders(),
        ...await _maybeEncodedRequest.getHeaders()
      },
      body: await _maybeEncodedRequest.getBody(),
      responseType: "streaming",
      timeoutMs: (requestOptions == null ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
      maxRetries: requestOptions == null ? void 0 : requestOptions.maxRetries,
      abortSignal: requestOptions == null ? void 0 : requestOptions.abortSignal
    });
    if (_response.ok) {
      return _response.body;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new BadRequestError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 401:
          throw new UnauthorizedError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 500:
          throw new InternalServerError(_response.error.body);
        default:
          throw new FileforgeError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new FileforgeError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new FileforgeTimeoutError();
      case "unknown":
        throw new FileforgeError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Splits a PDF document into 2 PDF documents. Returns a zip file containing the 2 documents. Each document is named after the original document with a suffix added to indicate the range of pages it contains.
   * @throws {@link Fileforge.BadRequestError}
   * @throws {@link Fileforge.UnauthorizedError}
   * @throws {@link Fileforge.InternalServerError}
   */
  async split(file, request, requestOptions) {
    const _request = new FormDataWrapper();
    await _request.append("options", JSON.stringify(request.options));
    await _request.append("file", file);
    const _maybeEncodedRequest = _request.getRequest();
    const _response = await fetcher({
      url: (0, import_url_join2.default)(await Supplier.get(this._options.environment) ?? FileforgeEnvironment.Default, "pdf/split/"),
      method: "POST",
      headers: {
        "X-Fern-Language": "JavaScript",
        "X-Fern-Runtime": RUNTIME.type,
        "X-Fern-Runtime-Version": RUNTIME.version,
        ...await this._getCustomAuthorizationHeaders(),
        ...await _maybeEncodedRequest.getHeaders()
      },
      body: await _maybeEncodedRequest.getBody(),
      responseType: "streaming",
      timeoutMs: (requestOptions == null ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
      maxRetries: requestOptions == null ? void 0 : requestOptions.maxRetries,
      abortSignal: requestOptions == null ? void 0 : requestOptions.abortSignal
    });
    if (_response.ok) {
      return _response.body;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new BadRequestError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 401:
          throw new UnauthorizedError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 500:
          throw new InternalServerError(_response.error.body);
        default:
          throw new FileforgeError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new FileforgeError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new FileforgeTimeoutError();
      case "unknown":
        throw new FileforgeError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Extracts a range of pages from a PDF document. The start and end pages are included in the extracted document. The extracted document is named after the original document with a suffix added to indicate the range of pages it contains (ex:document_extracted\_\$start\_\$end.pdf).
   * @throws {@link Fileforge.BadRequestError}
   * @throws {@link Fileforge.UnauthorizedError}
   * @throws {@link Fileforge.InternalServerError}
   */
  async extract(file, request, requestOptions) {
    const _request = new FormDataWrapper();
    await _request.append("options", JSON.stringify(request.options));
    await _request.append("file", file);
    const _maybeEncodedRequest = _request.getRequest();
    const _response = await fetcher({
      url: (0, import_url_join2.default)(await Supplier.get(this._options.environment) ?? FileforgeEnvironment.Default, "pdf/extract/"),
      method: "POST",
      headers: {
        "X-Fern-Language": "JavaScript",
        "X-Fern-Runtime": RUNTIME.type,
        "X-Fern-Runtime-Version": RUNTIME.version,
        ...await this._getCustomAuthorizationHeaders(),
        ...await _maybeEncodedRequest.getHeaders()
      },
      body: await _maybeEncodedRequest.getBody(),
      responseType: "streaming",
      timeoutMs: (requestOptions == null ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
      maxRetries: requestOptions == null ? void 0 : requestOptions.maxRetries,
      abortSignal: requestOptions == null ? void 0 : requestOptions.abortSignal
    });
    if (_response.ok) {
      return _response.body;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new BadRequestError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 401:
          throw new UnauthorizedError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 500:
          throw new InternalServerError(_response.error.body);
        default:
          throw new FileforgeError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new FileforgeError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new FileforgeTimeoutError();
      case "unknown":
        throw new FileforgeError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Insert a PDF document into another PDF document at a specified page. The inserted document is named after the original document with a suffix added to indicate the range of pages it contains (ex:document_inserted\_\$insertPage\_\$document2.pdf). Note: The first document is the parent document and the second document is the document to be inserted.
   * @throws {@link Fileforge.BadRequestError}
   * @throws {@link Fileforge.UnauthorizedError}
   * @throws {@link Fileforge.InternalServerError}
   */
  async insert(files, request, requestOptions) {
    const _request = new FormDataWrapper();
    await _request.append("options", JSON.stringify(request.options));
    for (const _file of files) {
      await _request.append("files", _file);
    }
    const _maybeEncodedRequest = _request.getRequest();
    const _response = await fetcher({
      url: (0, import_url_join2.default)(await Supplier.get(this._options.environment) ?? FileforgeEnvironment.Default, "pdf/insert/"),
      method: "POST",
      headers: {
        "X-Fern-Language": "JavaScript",
        "X-Fern-Runtime": RUNTIME.type,
        "X-Fern-Runtime-Version": RUNTIME.version,
        ...await this._getCustomAuthorizationHeaders(),
        ...await _maybeEncodedRequest.getHeaders()
      },
      body: await _maybeEncodedRequest.getBody(),
      responseType: "streaming",
      timeoutMs: (requestOptions == null ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
      maxRetries: requestOptions == null ? void 0 : requestOptions.maxRetries,
      abortSignal: requestOptions == null ? void 0 : requestOptions.abortSignal
    });
    if (_response.ok) {
      return _response.body;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new BadRequestError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 401:
          throw new UnauthorizedError(await ErrorSchema.parseOrThrow(_response.error.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            breadcrumbsPrefix: ["response"]
          }));
        case 500:
          throw new InternalServerError(_response.error.body);
        default:
          throw new FileforgeError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new FileforgeError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new FileforgeTimeoutError();
      case "unknown":
        throw new FileforgeError({
          message: _response.error.errorMessage
        });
    }
  }
  get form() {
    return this._form ?? (this._form = new Form(this._options));
  }
  async _getCustomAuthorizationHeaders() {
    const apiKeyValue = await Supplier.get(this._options.apiKey);
    return { "X-API-Key": apiKeyValue };
  }
};

// node_modules/@fileforge/client/dist/esm/client/codegen/Client.js
var FileforgeClient = class {
  constructor(_options = {}) {
    __publicField(this, "_options");
    __publicField(this, "_pdf");
    this._options = _options;
  }
  /**
   * Get the status of the API
   *
   * @param {FileforgeClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @example
   *     await fileforge.getStatus()
   */
  async getStatus(requestOptions) {
    const _response = await fetcher({
      url: (0, import_url_join3.default)(await Supplier.get(this._options.environment) ?? FileforgeEnvironment.Default, "status/"),
      method: "GET",
      headers: {
        "X-Fern-Language": "JavaScript",
        "X-Fern-Runtime": RUNTIME.type,
        "X-Fern-Runtime-Version": RUNTIME.version,
        ...await this._getCustomAuthorizationHeaders()
      },
      contentType: "application/json",
      timeoutMs: (requestOptions == null ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
      maxRetries: requestOptions == null ? void 0 : requestOptions.maxRetries,
      abortSignal: requestOptions == null ? void 0 : requestOptions.abortSignal
    });
    if (_response.ok) {
      return await GetStatusResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true,
        breadcrumbsPrefix: ["response"]
      });
    }
    if (_response.error.reason === "status-code") {
      throw new FileforgeError({
        statusCode: _response.error.statusCode,
        body: _response.error.body
      });
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new FileforgeError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new FileforgeTimeoutError();
      case "unknown":
        throw new FileforgeError({
          message: _response.error.errorMessage
        });
    }
  }
  get pdf() {
    return this._pdf ?? (this._pdf = new Pdf(this._options));
  }
  async _getCustomAuthorizationHeaders() {
    const apiKeyValue = await Supplier.get(this._options.apiKey);
    return { "X-API-Key": apiKeyValue };
  }
};

// node_modules/@fileforge/client/dist/esm/client/index.js
var Pdf2 = class extends Pdf {
  async generate(files, options, request) {
    var _a3;
    let parsedFiles = files;
    if (typeof files === "string") {
      parsedFiles = [
        new File([files], "index.html", {
          type: "text/html"
        })
      ];
    }
    const params = [
      parsedFiles,
      options,
      request
    ];
    const responseStream = await super.generate(...params);
    switch ((_a3 = options.options) == null ? void 0 : _a3.host) {
      case true:
        if (responseStream instanceof ReadableStream) {
          return await new Response(responseStream).json();
        } else {
          return JSON.parse(Buffer.concat(await responseStream.toArray()));
        }
      default:
        return responseStream;
    }
  }
};
var FileforgeClient2 = class extends FileforgeClient {
  get pdf() {
    return this._pdf ?? (this._pdf = new Pdf2(this._options));
  }
};
export {
  api_exports as Fileforge,
  FileforgeClient2 as FileforgeClient,
  Pdf2 as Pdf
};
//# sourceMappingURL=@fileforge_client.js.map
