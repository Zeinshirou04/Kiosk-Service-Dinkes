"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetcher = void 0;
const qs_1 = __importDefault(require("qs"));
const runtime_1 = require("../runtime");
const INITIAL_RETRY_DELAY = 1;
const MAX_RETRY_DELAY = 60;
const DEFAULT_MAX_RETRIES = 2;
async function fetcherImpl(args) {
    const headers = {};
    if (args.body !== undefined && args.contentType != null) {
        headers["Content-Type"] = args.contentType;
    }
    if (args.headers != null) {
        for (const [key, value] of Object.entries(args.headers)) {
            if (value != null) {
                headers[key] = value;
            }
        }
    }
    const url = Object.keys(args.queryParameters ?? {}).length > 0
        ? `${args.url}?${qs_1.default.stringify(args.queryParameters, { arrayFormat: "repeat" })}`
        : args.url;
    let body = undefined;
    const maybeStringifyBody = (body) => {
        if (body instanceof Uint8Array) {
            return body;
        }
        else {
            return JSON.stringify(body);
        }
    };
    if (args.body instanceof (await import("formdata-node")).FormData) {
        body = args.body;
    }
    else {
        try {
            const Readable = (await import("stream")).Readable;
            if (args.body instanceof Readable) {
                // @ts-expect-error
                body = args.body;
            }
            else {
                body = maybeStringifyBody(args.body);
            }
        }
        catch (e) {
            body = maybeStringifyBody(args.body);
        }
    }
    // In Node.js environments, the SDK always uses`node-fetch`.
    // If not in Node.js the SDK uses global fetch if available,
    // and falls back to node-fetch.
    const fetchFn = runtime_1.RUNTIME.type === "node"
        ? // `.default` is required due to this issue:
            // https://github.com/node-fetch/node-fetch/issues/450#issuecomment-387045223
            (await import("node-fetch")).default
        : typeof fetch == "function"
            ? fetch
            : (await import("node-fetch")).default;
    const makeRequest = async () => {
        const signals = [];
        // Add timeout signal
        let timeoutAbortId = undefined;
        if (args.timeoutMs != null) {
            const { signal, abortId } = getTimeoutSignal(args.timeoutMs);
            timeoutAbortId = abortId;
            signals.push(signal);
        }
        // Add arbitrary signal
        if (args.abortSignal != null) {
            signals.push(args.abortSignal);
        }
        const response = await fetchFn(url, {
            method: args.method,
            headers,
            body,
            signal: anySignal(signals),
            credentials: args.withCredentials ? "include" : undefined,
        });
        if (timeoutAbortId != null) {
            clearTimeout(timeoutAbortId);
        }
        return response;
    };
    try {
        let response = await makeRequest();
        for (let i = 0; i < (args.maxRetries ?? DEFAULT_MAX_RETRIES); ++i) {
            if (response.status === 408 ||
                response.status === 409 ||
                response.status === 429 ||
                response.status >= 500) {
                const delay = Math.min(INITIAL_RETRY_DELAY * Math.pow(i, 2), MAX_RETRY_DELAY);
                await new Promise((resolve) => setTimeout(resolve, delay));
                response = await makeRequest();
            }
            else {
                break;
            }
        }
        let body;
        if (response.body != null && args.responseType === "blob") {
            body = await response.blob();
        }
        else if (response.body != null && args.responseType === "streaming") {
            body = response.body;
        }
        else if (response.body != null && args.responseType === "text") {
            body = await response.text();
        }
        else {
            const text = await response.text();
            if (text.length > 0) {
                try {
                    body = JSON.parse(text);
                }
                catch (err) {
                    return {
                        ok: false,
                        error: {
                            reason: "non-json",
                            statusCode: response.status,
                            rawBody: text,
                        },
                    };
                }
            }
        }
        if (response.status >= 200 && response.status < 400) {
            return {
                ok: true,
                body: body,
                headers: response.headers,
            };
        }
        else {
            return {
                ok: false,
                error: {
                    reason: "status-code",
                    statusCode: response.status,
                    body: await response.json(),
                },
            };
        }
    }
    catch (error) {
        if (args.abortSignal != null && args.abortSignal.aborted) {
            return {
                ok: false,
                error: {
                    reason: "unknown",
                    errorMessage: "The user aborted a request",
                },
            };
        }
        else if (error instanceof Error && error.name === "AbortError") {
            return {
                ok: false,
                error: {
                    reason: "timeout",
                },
            };
        }
        else if (error instanceof Error) {
            return {
                ok: false,
                error: {
                    reason: "unknown",
                    errorMessage: error.message,
                },
            };
        }
        return {
            ok: false,
            error: {
                reason: "unknown",
                errorMessage: JSON.stringify(error),
            },
        };
    }
}
const TIMEOUT = "timeout";
function getTimeoutSignal(timeoutMs) {
    const controller = new AbortController();
    const abortId = setTimeout(() => controller.abort(TIMEOUT), timeoutMs);
    return { signal: controller.signal, abortId };
}
/**
 * Returns an abort signal that is getting aborted when
 * at least one of the specified abort signals is aborted.
 *
 * Requires at least node.js 18.
 */
function anySignal(...args) {
    // Allowing signals to be passed either as array
    // of signals or as multiple arguments.
    const signals = ((args.length === 1 && Array.isArray(args[0]) ? args[0] : args));
    const controller = new AbortController();
    for (const signal of signals) {
        if (signal.aborted) {
            // Exiting early if one of the signals
            // is already aborted.
            controller.abort(signal?.reason);
            break;
        }
        // Listening for signals and removing the listeners
        // when at least one symbol is aborted.
        signal.addEventListener("abort", () => controller.abort(signal?.reason), {
            signal: controller.signal,
        });
    }
    return controller.signal;
}
exports.fetcher = fetcherImpl;
//# sourceMappingURL=Fetcher.js.map