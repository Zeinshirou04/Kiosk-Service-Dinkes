{"version":3,"file":"getObjectLikeUtils.js","sourceRoot":"/","sources":["client/codegen/core/schemas/builders/object-like/getObjectLikeUtils.ts"],"names":[],"mappings":";;;AACA,2DAAwD;AACxD,iGAA8F;AAC9F,6DAA0D;AAC1D,kDAAiD;AAGjD,SAAgB,kBAAkB,CAAc,MAA+B;IAC3E,OAAO;QACH,oBAAoB,EAAE,CAAC,UAAU,EAAE,EAAE,CAAC,oBAAoB,CAAC,MAAM,EAAE,UAAU,CAAC;KACjF,CAAC;AACN,CAAC;AAJD,gDAIC;AAED;;GAEG;AAEH,SAAgB,oBAAoB,CAChC,UAAyD,EACzD,UAAuG;IAEvG,MAAM,YAAY,GAA+D;QAC7E,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE;YACvB,MAAM,YAAY,GAAG,MAAM,UAAU,CAAC,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;YACvD,IAAI,CAAC,YAAY,CAAC,EAAE,EAAE,CAAC;gBACnB,OAAO,YAAY,CAAC;YACxB,CAAC;YAED,MAAM,oBAAoB,GAAG,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,MAAM,CAC1D,CAAC,SAAS,EAAE,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE;gBACxB,OAAO;oBACH,GAAG,SAAS;oBACZ,CAAC,GAAG,CAAC,EAAE,OAAO,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK;iBACzE,CAAC;YACN,CAAC,EACD,EAAE,CACL,CAAC;YAEF,OAAO;gBACH,EAAE,EAAE,IAAI;gBACR,KAAK,EAAE;oBACH,GAAG,YAAY,CAAC,KAAK;oBACrB,GAAI,oBAAmC;iBAC1C;aACJ,CAAC;QACN,CAAC;QAED,IAAI,EAAE,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE;YACnB,IAAI,CAAC,IAAA,6BAAa,EAAC,MAAM,CAAC,EAAE,CAAC;gBACzB,OAAO;oBACH,EAAE,EAAE,KAAK;oBACT,MAAM,EAAE;wBACJ;4BACI,IAAI,EAAE,IAAI,EAAE,iBAAiB,IAAI,EAAE;4BACnC,OAAO,EAAE,IAAA,iEAA+B,EAAC,MAAM,EAAE,QAAQ,CAAC;yBAC7D;qBACJ;iBACJ,CAAC;YACN,CAAC;YAED,6BAA6B;YAC7B,MAAM,iBAAiB,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;YAC3D,MAAM,4BAA4B,GAAG,IAAA,2BAAY,EAC7C,MAAM,EACN,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,iBAAiB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CACnE,CAAC;YAEF,OAAO,UAAU,CAAC,IAAI,CAAC,4BAAiD,EAAE,IAAI,CAAC,CAAC;QACpF,CAAC;QAED,OAAO,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE;KACtC,CAAC;IAEF,OAAO;QACH,GAAG,YAAY;QACf,GAAG,IAAA,6BAAc,EAAC,YAAY,CAAC;QAC/B,GAAG,kBAAkB,CAAC,YAAY,CAAC;KACtC,CAAC;AACN,CAAC;AA7DD,oDA6DC","sourcesContent":["import { BaseSchema } from \"../../Schema\";\nimport { filterObject } from \"../../utils/filterObject\";\nimport { getErrorMessageForIncorrectType } from \"../../utils/getErrorMessageForIncorrectType\";\nimport { isPlainObject } from \"../../utils/isPlainObject\";\nimport { getSchemaUtils } from \"../schema-utils\";\nimport { ObjectLikeSchema, ObjectLikeUtils } from \"./types\";\n\nexport function getObjectLikeUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): ObjectLikeUtils<Raw, Parsed> {\n    return {\n        withParsedProperties: (properties) => withParsedProperties(schema, properties),\n    };\n}\n\n/**\n * object-like utils are defined in one file to resolve issues with circular imports\n */\n\nexport function withParsedProperties<RawObjectShape, ParsedObjectShape, Properties>(\n    objectLike: BaseSchema<RawObjectShape, ParsedObjectShape>,\n    properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }\n): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {\n    const objectSchema: BaseSchema<RawObjectShape, ParsedObjectShape & Properties> = {\n        parse: async (raw, opts) => {\n            const parsedObject = await objectLike.parse(raw, opts);\n            if (!parsedObject.ok) {\n                return parsedObject;\n            }\n\n            const additionalProperties = Object.entries(properties).reduce<Record<string, any>>(\n                (processed, [key, value]) => {\n                    return {\n                        ...processed,\n                        [key]: typeof value === \"function\" ? value(parsedObject.value) : value,\n                    };\n                },\n                {}\n            );\n\n            return {\n                ok: true,\n                value: {\n                    ...parsedObject.value,\n                    ...(additionalProperties as Properties),\n                },\n            };\n        },\n\n        json: (parsed, opts) => {\n            if (!isPlainObject(parsed)) {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: opts?.breadcrumbsPrefix ?? [],\n                            message: getErrorMessageForIncorrectType(parsed, \"object\"),\n                        },\n                    ],\n                };\n            }\n\n            // strip out added properties\n            const addedPropertyKeys = new Set(Object.keys(properties));\n            const parsedWithoutAddedProperties = filterObject(\n                parsed,\n                Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key))\n            );\n\n            return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);\n        },\n\n        getType: () => objectLike.getType(),\n    };\n\n    return {\n        ...objectSchema,\n        ...getSchemaUtils(objectSchema),\n        ...getObjectLikeUtils(objectSchema),\n    };\n}\n"]}